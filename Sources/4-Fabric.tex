\addtocontents{toc}{\newpage}
\chapter{Design and Implementation of Fabric}
\label{fabric}

In this short chapter, I present \textbf{\fabric{}} -- a functional programming language with structural subtyping. 
\fabric{}'s role in my thesis is roughly similar to that of \mlsub{} \cite{dolan-thesis}: my design (Section \ref{sec:fabric-design}) is driven by: \begin{itemize}
    \item Desire to statically type features present in dynamically typed languages, like Python or Lua.
    \item Applying \inference{} (Chapter \ref{algebraic-subtyping}) -- making \fabric{} an example of its expressive power.
\end{itemize}
Furthermore, in Section \ref{sec:fabric-impl} I explore the implementation of a \fabric{} compiler -- \compiler{} -- targeting \wasm{}, which includes a complete implementation of \inference{}. I thus report my practical experience working with \wasm{} and \inference{}.

\section{Design}
\label{sec:fabric-design}

The basis of \fabric{} is Chapter \ref{static-soul}'s Featherweight Lua, extended with more record operations, variants, tuples, and \emph{nominal type abbreviations}. \fabric{} is essentially a superset of \mlsub{} \cite{mlsub} -- and I consider extensions proposed by \textcite{dolan-thesis}) -- and is influenced by \mlstruct{} \cite{mlstruct}.\todo[color=green]{expr}\todo[color=green]{opsem}\todo[color=green]{types}\todo[color=green]{typing}

Due to time (and space) constraints, I only state type safety (Progress and Preservation) for \starr{} (Chapter~\ref{star}; Section \ref{subsec:type-safety}). However, \fabric{}'s design is also intended to admit type safety.

Selected \fabric{} programs written in code accepted by \compiler{} are given in Figures~\ref{fig:fabric-example-eval}~and~\ref{fig:fabric-example-pairwise}.


\begin{figure}[p]
    \centering
    \input{Sources/5-Figures/Fabric-eval}
    \caption{\fabric{} program implementing a recursive function for evaluating arithmetic expressions, where some nodes return a \enquote{default} value. Code generated by \compiler{} correctly computes \mintinline{ocaml}{7}. \inference{} infers a polymorphic type scheme for \mintinline{ocaml}{eval}, \eg{} rejecting \mintinline{ocaml}{eval (Lit {})}.}
    \label{fig:fabric-example-eval}
\end{figure}

\begin{figure}[p]
    \centering
    \input{Sources/5-Figures/Fabric-pairwise}
    \caption{\fabric{} program implementing functions \texttt{stutter} (duplicating elements in a list, doubling its length) and \texttt{pairwise} (pairing adjacent elements of an \textbf{even-length} list). \inference{} detects an error: \texttt{pairwise} is passed an odd-length list. Inferring such properties with algebraic subtyping is explored by \citeauthor*{structural-refinement-types}~\cite{structural-refinement-types}.}
    \label{fig:fabric-example-pairwise}
\end{figure}

\subsubsection{Data types}

I focus on describing records and variants, though \fabric{} also has \eg{} an integer type with arithmetic operations.
\begin{description}
\item[Records]
Beyond FL, I add field restriction $e \fbrestricted \ell$ \cite{operations-on-records} and checked-projection $\fbcheck{e}{\ell}$ (accompanied by an \enquote{optional} field type, $?\boxed{\tau}$), inspired by operations for objects in dynamic languages.

In contrast to \textcite{mlstruct}, I do not use \textsc{Forsythe}-style singleton record types \cite{forsythe}, as they lead to a surprising type lattice.\footnote{\eg{}: in \mlstruct{} $\flrec{x : \alpha} \join \flrec{y: \beta} = \top \implies \comp \flrec{ x : \alpha } \sub \flrec{ y : \beta } $, as \emph{there is no empty record type} \cite[Section~4.4.5]{mlstruct}.} Instead, I rely on the same \emph{partial-function} strategy for representing record (and variant) types as in FL (Section \ref{subsec:featherweight-lua}).

\item[Variants] Following suggestions of \textcite[Section~9.2]{dolan-thesis}, I add variants $\fbtag{T}{e}$ to \fabric{} (and a $\mathrm{match}$), though not in the form of his \emph{tagged records}. To address his motivating example, I instead propose \emph{untagging} -- pattern matching on \emph{any} tag -- easily type checked with my syntax of variant types.
\end{description}

\subsubsection{Patterns}
Structural typing invites a rich pattern matching facility, as explored by \eg{} \textcite{parreaux-patterns}. I also designed one for \fabric{}, using conservative typing rules to ensure exhaustive matches. 

\subsubsection{Nominal types} 
It is known that combining both nominal and structural types is desirable \cite{mlstruct, integrating-nominal-and-structural}. In \fabric{}, I propose a way of doing so inspired by OCaml's \href{https://ocaml.org/manual/5.1/privatetypes.html#ss:private-types-abbrev}{private type abbreviations}.

\emph{Nominal abbreviations} $\nom$ in \fabric{} are declared via $\mathrm{type}\,\nom=\tau\,\mathrm{in}\,e$. They are introduced and eliminated via \textbf{abbreviation-casts} $\fbcast{e}{\tau}{\tau'}$, well-typed exactly when $\tau$ is a subtype of $\tau'$ \emph{up to type abbreviations}, and $e$ is a subtype of $\tau$. The intermediate type $\tau$ is key for type checking.

The same problem is addressed by \textcite{mlstruct}. However, their approach -- \emph{nominal tags} (reminiscent of Dolan's \emph{tagged records}) -- \emph{refines} existing structural types. It thus does not create a truly nominal type, and requires dedicated runtime support for pattern matching.

This strategy of adding nominal types of the system could lead to integrating algebraic subtyping with higher-kinded types and higher-rank polymorphism (as set out by \textcite[Section~11.1]{dolan-thesis}). 

\section{Implementation}
\label{sec:fabric-impl}

I used OCaml for implementing \compiler{}. My main dependencies are: \href{https://opensource.janestreet.com/core/}{Core}, \href{https://github.com/janestreet/ppx_jane}{\texttt{ppx\_jane}} (pre-processor macros, S-expressions), \href{https://github.com/mirage/alcotest}{\texttt{alcotest}} (test framework), and \href{https://github.com/inhabitedtype/angstrom}{\texttt{angstrom}} (parser combinators).

The implementation is complete with minor omissions (\eg{} compound pattern matching).\todo{revise} For brevity, I describe interesting aspects of type inference (Section \ref{subsec:type-inference-impl}) and code generation (Section~\ref{subsec:codegen}).

\subsection{Type inference} 
\label{subsec:type-inference-impl}

I devised an implementation of \inference{} usable with any type system implementing its signature -- not just for \fabric{}, but for any language for which we can generate constraints.

\subsubsection{Exploiting the module language} The framework was particularly satisfying to implement using OCaml's module language. Firstly, the framework's signature is given by an module \emph{signature} (given in Figure \ref{fig:inference-signature}). Type systems satisfying are specified by an \emph{implementation} module satisfying the signature, from which we can derive all aspects of constraint solving and simplification via a \emph{functor}.

\begin{figure}[p]
    \centering
    \input{Sources/5-Figures/Warp-signature}
    \caption{The key parts of the OCaml module signature of a type system suitable for type inference.}
    \label{fig:inference-signature}
\end{figure}

\subsubsection{Type language representations} \inference{}'s OCaml signature is polymorphic with respect to different type languages. 
% This is because we have to change between different representations of types. 
Usually, we use the full type language (following \inference{}'s $\tau$), represented using the OCaml type \texttt{Alg.t}. On the other hand, in constraint solving we rely on the use of normal forms -- the clause-based CNF/DNF (\texttt{CNF.t}/\texttt{DNF.t}). As CNF--DNF conversion can blow up the number of clauses, we manipulate constraints as $\tau_\mathrm{dnf} \sub \tau_\mathrm{cnf}$. To avoid code duplication, I implement DNF in terms of CNF, exploiting the duality between them. 

% \subsubsection{Constraint solving} As advertised, the implementation of constraint solving is close to the technical description in Section \ref{sec:constraints}. It is infeasible to solve constraints directly by pattern matching on $\tau$/\texttt{Alg.t} due to mismatched-polarity cases like $\alpha \join \beta \sub \gamma \meet \delta$.

\subsubsection{Simplification of type schemes} In Section \ref{subsec:simplification} I hinted at the possible approaches to simplifying the result of type inference. I implemented most heuristics proposed by \textcite{simple-sub} and \textcite{mlstruct}.\footnote{Notably, I omitted \emph{unification of indistinguishable variables} and \emph{hash-consing}.} 
% \begin{itemize}
%     \item Simplification of CNF/DNF forms: removing subsumed clauses and clauses equal to $\top$/$\bot$.
%     \item Inlining bounds: replacing a type variable with its bound if it only occurs in co/contravariant positions.
%     \item Sandwich inequalities: if we find $\tau \sub \alpha \sub \tau$, then we can substitute $\alpha$ for $\tau$.
% \end{itemize}
However, this subset has proven unsatisfactory, often returning redundant type variables that could be simplified by-hand. This limitation is mainly due to the time-consuming implementation. 
Besides Parreaux's other heuristics, it would be interesting to try automata-simplification of \textcite[Chapter~7]{dolan-thesis}.

\subsubsection{Constraint generation} I devised a simple DSL to make constraint generation straightforward (example in Figure \ref{fig:cstr-gen}). I used OCaml's let-binding operators for composing constraints and introducing fresh type variables, giving the code a declarative feel. 

\begin{figure}
    \centering
\begin{cminted}{ocaml}
| Let (p, e, e') ->
    let* xs, t = pat p in
    let* e = go env e in
    let* () = e <: t in
    go (push xs env) e'
\end{cminted}
    \caption{Example of constraint generation for \fabric{} let-bindings ($\fllet p e e'$). Here, \texttt{go env e} stands for a type $\tau$ such that $\texttt{env} \vdash \texttt{e} : \tau$ (under some carried constraint) -- a slight deviation from the specification.}
    \label{fig:cstr-gen}
\end{figure}

\subsection{Code generation} 
\label{subsec:codegen}

In order to execute \fabric{} code, I sought to generate code that could be lowered directly to machine code. I chose to go with \wasm{} \cite{wasm} and to use the \binaryen{} \cite{binaryen} toolchain, because it is modern, stable, relatively high-level, and well-documented.\footnote{I also considered other targets -- C, Lua, .NET or JVM bytecode, or LLVM. Ultimately, I thought using \wasm{} would be easiest and most interesting.} Furthermore, I wanted to explore its new extension with garbage collection \cite{wasm-gc}, enabling automatic memory management for \fabric{}.

\binaryen{} is only accessible from OCaml using the C~API.\footnote{There are ready solutions -- like \href{https://github.com/grain-lang/binaryen.ml}{\texttt{binaryen.ml}} -- but outdated (\eg{} no \textsc{WasmGC}) or broken with newer \binaryen{} versions.} I used the brilliant work of \textcite{ocaml-ctypes} on \href{https://github.com/yallop/ocaml-ctypes}{\texttt{ocaml-ctypes}} to produce my own, type-safe bindings.

Invoking bindings directly led to clumsy, imperative code. Inspired by \textcite{offshoring-c}, I created a DSL on top of \binaryen{} dubbed \binaryendsl{}. Its most prevalent abstraction is \texttt{Cell} (Figure \ref{fig:cell-def}), which encapsulates the different types of storage available in \wasm{}, making it easier to write generic helpers for code generation.
I give a basic example of using \binaryendsl{} in Figure \ref{fig:binaryer-example}. 

I used \binaryendsl{} to implement code generation for almost all of \fabric{}. I included a suite of unit tests using a basic printing function, \texttt{\%print\_i32}, provided by \binaryen{}.

\begin{figure}[p]
    \centering
    \input{Sources/5-Figures/Weaver-cell}
    \caption{Definition of a \texttt{Cell.t} -- abstracting over locals, globals, tables, memory addresses, structure fields, and array elements. I also give the signature of its two primitives: read (\texttt{!}) and write (\texttt{:=}). 
    % \texttt{T.<thing>.t} is the OCaml type for \binaryen{}'s representation of \texttt{<thing>}s.
    }
    \label{fig:cell-def}
\end{figure}

\begin{figure}[p]
    \centering
    \input{Sources/5-Figures/Binaryer}
    \caption{Basic program defined using \binaryendsl{}. Under the hood, it calls \binaryen{}'s API, producing \wasm{} code (given in Appendix \ref{extra:codegen}) which prints \texttt{1337} at runtime.}
    \label{fig:binaryer-example}
\end{figure}

\subsubsection{Runtime representation under subtyping}

It is well-known that structural typing makes the problem of efficiently representing values at runtime more difficult, as a value might be used as any supertype \cite{tapl}. 

This problem also arises for \fabric{}'s record and variant types: 
\begin{description}
    \item[Variants] I implemented the same approach as \textcite{polymorphic-variants} -- variant values are represented as a pair of a 32-bit hash of its tag and a reference to its payload.
    \item[Records] Due to time (and space) constraints, I did not experiment with record representations, and stuck to a na\"ive one (with linear-time projection). One interesting direction would be the work of \textcite{remy-extensible-records}, where a record is a hash table with a pre-computed hashing function (so projection is constant-time). 
\end{description}

\needspace{7em}
\section{Conclusions}

I summarise my experience with the three main areas covered in this chapter: the use and implementation of \inference{}, targeting \wasm{}, and the design of languages for algebraic subtyping. 
% I also give some more code examples in Appendix \ref{extra:fabric}.\todo[color=green]{extra}

\paragraph{Experience with \inference{}}
% His work resulted in \textsc{Inferno}, a framework for constraint-based Hindley-Milner type inference -- I performed a similar task in a setting with subtyping. 
By separating concerns of the type and constraint languages in my implementation of \compiler{}, I was able to experiment with type inference for not only \fabric{}, but also \starr{} (Chapter \ref{star}). \textcite{pottier-framework} also outlined the benefits of such a type inference framework. Unfortunately, type signatures for complex programs are unclear -- mostly due to my incomplete simplification. 

\paragraph{Experience with \wasm{}}
I found that while the \wasm{} tooling for high-level languages is limited, good bespoke solutions are possible. However, \binaryen{} specifically could improve its error diagnostics for invalid emitted programs, as debugging was difficult. \wasm{}'s formal specification and stability are great boons towards its practical use.
However, I observed that the current design of automatically managed reference types is limiting in terms of achievable performance, \eg{} making some efficient memory representations impossible \cite{double-ended-bit-stealing}.

\paragraph{Language design with algebraic subtyping} Constructing a lattice of type constructors was helpful in preventing misbehaved type system features, and did not prove to be a constraint. Rapidly experimenting with new features using \inference{} was liberating during design.
