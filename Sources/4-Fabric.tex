\addtocontents{toc}{\newpage}
\chapter{Design and Implementation of Fabric}
\label{fabric}

In this short chapter, I present \textbf{\fabric{}} -- a functional programming language with structural subtyping. 
\fabric{}'s role in my thesis is similar in goal to that of \mlsub{} \cite{dolan-thesis}: exhibiting type inference. My design (Section~\ref{sec:fabric-design}) is driven by: \begin{itemize}
    \item Applying \inference{} (Chapter \ref{algebraic-subtyping}) -- making \fabric{} an example of its expressive power.
    \item Desire to statically type features present in dynamically languages (Python, Lua).
\end{itemize}
Furthermore, in Section \ref{sec:fabric-impl} I explore the implementation of my \fabric{} compiler -- \compiler{} -- targeting \wasm{}, which includes a complete implementation of \inference{}. I thus report my practical experience working with \wasm{} and \inference{}.

\section{Design}
\label{sec:fabric-design}

The basis of \fabric{} is Chapter \ref{static-soul}'s Featherweight Lua, extended with more record operations, variants, tuples, and \emph{nominal type abbreviations}. \fabric{} is essentially a superset of \mlsub{} \cite{mlsub} -- I consider Dolan's proposed extensions \cite[Chapter~9]{dolan-thesis} -- and is influenced by \mlstruct{} \cite{mlstruct}. 
A formal development for \fabric{} is given in Appendix \ref{extra:fabric}.

% Due to time (and space) constraints, I only state type safety (Progress and Preservation) for \starr{} (Chapter~\ref{star}; Section \ref{subsec:type-safety}). However, \fabric{}'s design is also intended to admit type safety.

Selected \fabric{} programs written in code accepted by \compiler{} are given in Figures~\ref{fig:fabric-example-eval}~and~\ref{fig:fabric-example-pairwise}.


\begin{figure}[p]
    \centering
    \input{Sources/4-Figures/Fabric-eval}
    \caption{\fabric{} program implementing a recursive function for evaluating arithmetic expressions, where some nodes return a \enquote{default} value. Code generated by \compiler{} correctly computes \mintinline{ocaml}{7}. \inference{} infers a polymorphic type scheme for \mintinline{ocaml}{eval}, \eg{} rejecting \mintinline{ocaml}{eval (Lit {})}. Note $\fllam x e$ is written \texttt{x => e}.}
    \label{fig:fabric-example-eval}
\end{figure}

\begin{figure}[p]
    \centering
    \input{Sources/4-Figures/Fabric-pairwise}
    \caption{\fabric{} program implementing functions \texttt{stutter} (duplicating elements in a list, doubling its length) and \texttt{pairwise} (pairing adjacent elements of an \textbf{even-length} list). \inference{} detects an error: \texttt{pairwise} is passed an odd-length list. Inferring such properties with algebraic subtyping is explored by \citeauthor*{structural-refinement-types}~\cite{structural-refinement-types}.}
    \label{fig:fabric-example-pairwise}
\end{figure}

\subsubsection{Data types}

I focus on describing records and variants, though \fabric{} also has tuples and integers.
\begin{description}
\item[Records]
Beyond FL, I add field restriction $e \fbrestricted \ell$ \cite{operations-on-records} and checked-projection $\fbcheck{e}{\ell}$ (accompanied by an \enquote{optional} field type, $?\boxed{\tau}$), inspired by operations for objects in dynamic languages.

In contrast to \textcite{mlstruct}, I do not use \textsc{Forsythe}-style singleton record types \cite{forsythe}, as they lead to a confusing type lattice.\footnote{\eg{}: in \mlstruct{} $\flrec{x : \alpha} \join \flrec{y: \beta} = \top \implies \comp \flrec{ x : \alpha } \sub \flrec{ y : \beta } $, as \emph{there is no empty record type} \cite[Section~4.4.5]{mlstruct}.} Instead, I rely on the same \emph{partial-function} strategy for representing record (and variant) types as in FL (Section \ref{subsec:featherweight-lua}).

\item[Variants] Following suggestions of \textcite[Section~9.2]{dolan-thesis}, I add variants $\fbtag{T}{e}$ to \fabric{} (and a $\mathrm{match}$), though not in the form of his \emph{tagged records}. To address his motivating example, I instead propose \emph{untagging} -- pattern matching on \emph{any} tag -- easily type checked with my syntax of variant types.
\end{description}

\subsubsection{Patterns}
Structural typing invites a rich pattern-matching facility \cite{parreaux-patterns}. I provide a sketch of a design for \fabric{} in Appendix \ref{extra:fabric}, using conservative typing rules to ensure exhaustive matches. 

\subsubsection{Nominal types} 
Combining both nominal and structural types is desirable \cite{mlstruct, integrating-nominal-and-structural}. In \fabric{}, I propose a method inspired by OCaml's \href{https://ocaml.org/manual/5.1/privatetypes.html#ss:private-types-abbrev}{private type abbreviations}.
\emph{Nominal abbreviations} $\nom$ in \fabric{} are declared via $\mathrm{type}\,\nom=\tau\,\mathrm{in}\,e$. They are introduced and eliminated via \textbf{abbreviation-casts} $\fbcast{e}{\tau}{\tau'}$, well-typed exactly when $\tau$ is equal to $\tau'$ \emph{up to abbreviations}, and $e$ is of type $\tau$. The intermediate type $\tau$ is key for type checking.

The same problem is addressed by \textcite{mlstruct}. Their approach -- \emph{nominal tags} (reminiscent of Dolan's \emph{tagged records}) -- \emph{refines} existing structural types, and requires dedicated runtime support.

This strategy of adding nominal types to the system could lead to integrating algebraic subtyping with higher-kinded types and higher-rank polymorphism (as set out by \textcite[Section~11.1]{dolan-thesis}). 

\section{Implementation}
\label{sec:fabric-impl}

I used OCaml for implementing \compiler{}. My main dependencies are: \href{https://opensource.janestreet.com/core/}{Core}, \href{https://github.com/janestreet/ppx_jane}{\texttt{ppx\_jane}} (pre-processor macros, S-expressions), \href{https://github.com/mirage/alcotest}{\texttt{alcotest}} (test framework), and \href{https://github.com/inhabitedtype/angstrom}{\texttt{angstrom}} (parser combinators).

The implementation is complete with minor omissions.\footnote{Mainly: compound pattern matching, nominal types, and code generation for recursive let-bindings (but not the Y combinator) and record extension/restriction (except type inference).} For brevity, I describe interesting aspects of type inference (Section \ref{subsec:type-inference-impl}) and code generation (Section~\ref{subsec:codegen}).

\subsection{Type inference} 
\label{subsec:type-inference-impl}

I devised an implementation of \inference{} usable with any type system implementing its signature -- not just for \fabric{}, but for any language for which we can generate constraints.

% A test suite provides evidence for Termination, Completeness, and (by inspection) Principality of \inference{}.

\subsubsection{Exploiting the module language} The framework was particularly satisfying to implement using OCaml's module language. Firstly, the framework's signature is given by an module \emph{signature} (given in Figure \ref{fig:inference-signature}). Type systems are specified by an \emph{implementation} module satisfying the signature, from which a \emph{functor} derives the constraint solver.

\begin{figure}[p]
    \centering
    \input{Sources/4-Figures/Warp-signature}
    \caption{The key parts of the OCaml module signature of a type system suitable for type inference.}
    \label{fig:inference-signature}
\end{figure}

\subsubsection{Type language representations} \inference{}'s OCaml signature is polymorphic with respect to different type languages. 
% This is because we have to change between different representations of types. 
Usually, we use the full type language (following \inference{}'s $\tau$), represented using the OCaml type \texttt{Alg.t}. On the other hand, in constraint solving we rely on the use of normal forms -- the clause-based CNF/DNF (\texttt{CNF.t}/\texttt{DNF.t}). As CNF--DNF conversion can blow up the number of clauses, we manipulate constraints as $\tau_\mathrm{dnf} \sub \tau_\mathrm{cnf}$. To avoid code duplication, I implement DNF in terms of CNF, exploiting the duality between them. 

% \subsubsection{Constraint solving} As advertised, the implementation of constraint solving is close to the technical description in Section \ref{sec:constraints}. It is infeasible to solve constraints directly by pattern matching on $\tau$/\texttt{Alg.t} due to mismatched-polarity cases like $\alpha \join \beta \sub \gamma \meet \delta$.

\subsubsection{Simplification of type schemes} In Section \ref{subsec:simplification} I hinted at possible approaches to simplifying type schemes. I implemented most heuristics proposed by \textcite{simple-sub} and \textcite{mlstruct}.\footnote{Notably, I omitted \emph{unification of indistinguishable variables} and \emph{hash-consing}.} 
% \begin{itemize}
%     \item Simplification of CNF/DNF forms: removing subsumed clauses and clauses equal to $\top$/$\bot$.
%     \item Inlining bounds: replacing a type variable with its bound if it only occurs in co/contravariant positions.
%     \item Sandwich inequalities: if we find $\tau \sub \alpha \sub \tau$, then we can substitute $\alpha$ for $\tau$.
% \end{itemize}
However, this subset has proven unsatisfactory, often returning redundant type variables that could be simplified by-hand. This limitation is mainly due to the time-consuming implementation. 
Besides Parreaux's other heuristics, it would be interesting to try automata-simplification of \textcite[Chapter~7]{dolan-thesis}.

\subsubsection{Constraint generation} I devised a simple DSL for constraint generation (example in Figure \ref{fig:cstr-gen}), using OCaml's let-binding operators for composing constraints and introducing fresh type variables, giving the code a declarative feel. 

\begin{figure}
    \centering
\begin{cminted}{ocaml}
Let (p, e, e') ->
  let* xs, t = pat p in
  let* e = go env e in
  let* () = e <: t in
  go (push xs env) e'
\end{cminted}
    \caption{Example of constraint generation for \fabric{} let-bindings ($\fllet p e e'$). Here, \texttt{go env e} stands for a type $\tau$ such that $\texttt{env} \vdash \texttt{e} : \tau$ (under some carried constraint) -- a slight deviation from \inference{}'s specification.}
    \label{fig:cstr-gen}
\end{figure}

\subsection{Code generation} 
\label{subsec:codegen}

In order to execute \fabric{} code, I sought to generate code that could be lowered directly to machine code. I chose to go with \wasm{} \cite{wasm} and to use the \binaryen{} \cite{binaryen} toolchain, because it is modern, stable, relatively high-level, and well-documented.\footnote{I also considered other targets -- C, Lua, .NET or JVM bytecode, or LLVM. Ultimately, I thought using \wasm{} would be easiest and most interesting.} Furthermore, I wanted to explore its new extension with garbage collection \cite{wasm-gc}, enabling automatic memory management for \fabric{}.

\binaryen{} is only accessible from OCaml using the C~API.\footnote{There are ready solutions -- like \href{https://github.com/grain-lang/binaryen.ml}{\texttt{binaryen.ml}} -- but outdated (\eg{} no \textsc{WasmGC}) or broken with newer \binaryen{} versions.} I used the brilliant work of \textcite{ocaml-ctypes} on \href{https://github.com/yallop/ocaml-ctypes}{\texttt{ocaml-ctypes}} to produce my own, type-safe bindings.

Invoking bindings directly led to clumsy, imperative code. Inspired by \textcite{offshoring-c}, I created a DSL on top of \binaryen{} dubbed \binaryendsl{}. Its most prevalent abstraction is \texttt{Cell} (Figure \ref{fig:cell-def}), which encapsulates the different types of storage available in \wasm{}, making it easier to write generic helpers for code generation.
I give a basic example of using \binaryendsl{} in Figure \ref{fig:binaryer-example}. 

I used \binaryendsl{} to implement code generation for almost all of \fabric{}. I included a suite of unit tests using a basic printing function, \texttt{\%print\_i32}, provided by \binaryen{}.

\begin{figure}[p]
    \centering
    \input{Sources/4-Figures/Weaver-cell}
    \caption{Definition of \texttt{Cell.t} -- abstracting over locals, globals, tables, memory addresses, structure fields, and array elements. I also give the signature of its two primitives: read (\texttt{!}) and write (\texttt{:=}). 
    % \texttt{T.<thing>.t} is the OCaml type for \binaryen{}'s representation of \texttt{<thing>}s.
    }
    \label{fig:cell-def}
\end{figure}

\begin{figure}[p]
    \centering
    \input{Sources/4-Figures/Binaryer}
    \caption{Basic program defined using \binaryendsl{}. Under the hood, it calls \binaryen{}'s API, producing \wasm{} code (given in Appendix \ref{extra:codegen}) which prints \texttt{1337} at runtime.}
    \label{fig:binaryer-example}
\end{figure}

\subsubsection{Runtime representation under subtyping}

It is well-known that structural typing makes the problem of efficiently representing values at runtime more difficult, as a value might be used as any supertype \cite{tapl}. 

This problem also arises for \fabric{}'s record and variant types: 
\begin{description}
    \item[Variants] I implemented the same approach as \textcite{polymorphic-variants} -- variant values are represented as a pair of a 32-bit hash of its tag and a reference to its payload.
    \item[Records] Due to time constraints, I did not experiment with record representations, and stuck to a na\"ive one (with linear-time projection). One interesting direction would be the work of \textcite{remy-extensible-records}, where a record is a hash table with a pre-computed hashing function (so projection is constant-time). 
\end{description}

\needspace{7em}
\section{Conclusions}

I summarise my experience with the three main areas covered in this chapter: the use and implementation of \inference{}, targeting \wasm{}, and the design of languages for algebraic subtyping. 
% I also give some more code examples in Appendix \ref{extra:fabric}.\todo[color=green]{extra}

\paragraph{Experience with \inference{}}
% His work resulted in \textsc{Inferno}, a framework for constraint-based Hindley-Milner type inference -- I performed a similar task in a setting with subtyping. 
By separating concerns of the type and constraint languages in my implementation of \compiler{}, I was able to experiment with type inference for not only \fabric{}, but also \starr{} (Chapter \ref{star}) -- confirming the benefits outlined by \textcite{pottier-framework}. I have also seen the importance of complete type scheme simplification. 

\paragraph{Experience with \wasm{}}
While the \wasm{} tooling for high-level languages is limited, good bespoke solutions are possible. However, \binaryen{} had poor error diagnostics for invalid programs, making debugging difficult. \wasm{}'s formal specification and stability are great boons towards its practical use.
I observed that the current design of automatically managed reference types is limiting in terms of achievable performance, \eg{} making some efficient memory representations impossible~\cite{double-ended-bit-stealing}.

\paragraph{Language design with algebraic subtyping} Constructing a lattice of types was helpful in preventing misbehaved type system features, and did not prove to be a constraint. Rapidly experimenting with new features using \inference{} was liberating during design.
