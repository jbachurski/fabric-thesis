\chapter{Introduction}
\label{introduction}

Programs written in dynamically typed languages form a large fraction of modern programming. 
For many programmers, they are they easier to program in and enable more rapid development.
By leaving the programmer unrestricted by a static type system, dynamic languages are more \textbf{expressive} -- admitting more programs, many of which are useful, despite their lack of statically known types -- and thus more flexible, though also less safe.

Furthermore, for many domains -- such as array programming or data science, both of which are relevant to machine learning -- it has become a commonplace assumption that static type systems are too restrictive and get in the way of the programmer. Hence, programming in these domains is virtually always done without static types.
Thus, dynamic typing has become not only a matter of preference for higher expressiveness at the cost of safety, but also a \textbf{convention} in some domains.

\section{Strategy}

The benefits of static typing are clear, and researching approaches to bestowing static typing on otherwise dynamically typed programs is a useful problem to resolve -- proven in practice by the success of TypeScript (JavaScript's typed dialect) or Python's optional typing system. 
Obviously, not all dynamically typed programs can admit static typing under a reasonably complex type system. 
Hence, we must consider what \textbf{characteristics} of dynamically typed programs we are interested in capturing, and what \textbf{properties} we desire from our static type system. 

Given these desiderata, we can determine an \textbf{approach} for statically typing a reasonably large subset of programs with the target characteristics.
Having found such an approach, we can then inform the design of a statically typed language. 
Since we derived it by statically typing dynamically typed programs, we retain the expressivity of dynamic languages. However, in contrast to them, we can statically guarantee safety of the entire language.
We get the best of both worlds: a sliver of the expressiveness of dynamic languages with a healthy dose of statically ensured safety.

The design of a new language is not in itself useful, but it productively informs the evolution and extension of existing languages.
By restricting ourselves to solutions which work within the scope of our approach to static typing, we can also attempt to identify novel approaches to programming in domains which are traditionally untyped, upending existing conventions for dynamic typing. 

\section{Overview}

The thesis follows the strategy proposed in the previous section, and is split into several chapters. Each chapter offers contributions in different areas.

\subsubsection{Structural Subtyping: The Static Soul of Dynamic Languages.} 

I identify \textbf{duck typing} as a powerful characteristic pattern applied in dynamically typed programs. I propose \textbf{structural subtyping} as the mechanism for modelling duck typing statically. 

In need of a good model for a dynamic language, I introduce \textbf{Featherweight Lua} (FL) -- a simple $\lambda$ calculus with extensible records, following the tradition of object calculi \cite{abadi-cardelli-object-calculus}. I then give it a static type system with structural subtyping, capturing a \emph{well-behaved} subset of FL.

To show that FL remains adequately powerful when typed statically, I develop a \textbf{translation} from the well-known \textbf{Featherweight Java} (FJ) into FL. 
I thus formally show the intuitive notion that we can obtain a structurally typed language by erasing type definitions from a nominally typed one.
Indeed, the FJ-FL translation preserves well-typedness -- showing that the statically typed fragment of FL is at least as expressive as FJ, but without requiring any type definitions. 

To truly model a dynamic language, we need to rid programs of type annotations. This naturally leads to the question of providing \emph{type inference} for FL -- and generally, any language with a type system relying on structural subtyping -- which I address in the next chapter.

\subsubsection{Constraint-Based Algebraic Subtyping}

By using the recently invented \textbf{algebraic subtyping} technique, I develop a general \textbf{type inference framework} for languages with structural subtyping. 
The framework builds on the state-of-the-art work on algebraic subtyping -- enabling \textit{ML-style type inference}, combining parametric polymorphism with subtyping. 

Furthermore, I show an extension of algebraic subtyping with \textbf{type lattice homomorphisms}. Using them, I show type inference for extensible records -- as present in FL -- without the usual need for extending the type system with row polymorphism.

The description of the type inference approach is \emph{independent} of specific expression and type languages. Instead, it is given in terms of a generic \textbf{constraint language} and \textbf{solver} and some requirements. 

With this framework in hand, I can freely take advantage of its flexibility by designing a new language.

\subsubsection{Design and Implementation of Fabric}
I present my \textbf{design} of a functional language with structural subtyping -- \textbf{Fabric}. 
I consider case studies in which I show how Fabric can express patterns naturally possible in dynamically typed languages, but difficult without structural subtyping. 

I also investigate Fabric's \textbf{implementation} as a general-purpose programming language featuring structural subtyping and describe my compiler for it. In particular, I consider the implications of supporting structural subtyping on code generation -- for which I target WebAssembly.

As part of my Fabric compiler, I give a prototype implementation of the described type inference approach. It features a dedicated constraint generation routine for Fabric (and thus FL) -- showcasing that the type inference approach is indeed independent of the specific language specification.

\subsubsection{Structuring Arrays with Algebraic Shapes}
Inspired by the use of structural subtyping, I propose a novel statically typed calculus for array programming -- \textbf{Star}. 

The standard in practical array programming has been to forgo types, with dependent type systems proposed as virtually the only options for static typing. I instead propose a middle-ground: rich structural types for array shapes, helping the programmer build abstractions and avoid menial index arithmetic. At the same time, Star also admits type inference using my framework.

This chapter is based on a paper of the same name, which was written as part of the work on my thesis and coauthored with my supervisors. It was accepted for publication in the Proceedings of the 11th ACM ARRAY Workshop. 