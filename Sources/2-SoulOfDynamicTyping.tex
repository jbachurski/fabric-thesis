\chapter
    [Structural Subtyping: The Static Soul of Dynamic Languages]
    {Structural Subtyping: \newline The Static Soul of Dynamic Languages}
\label{static-soul}

We begin by exploring characteristics of dynamically typed programs that we wish to type statically. I~propose for \textbf{duck typing} to be the key characteristic we should focus our attention on, and argue -- via the introduction of \emph{translations} -- that \textbf{structural subtyping} is a good solid approach for statically modelling this pattern.

This chapter both builds the motivation of this thesis, and introduces various key concepts -- such as nominal or structural (sub)typing -- that arise throughout the report.

\section{Background}
\label{sec:background}

We begin by considering what we mean by \emph{dynamic} and \emph{static} typing.

\emph{Dynamic typing} generally means any form of runtime type checking, while \emph{static typing} is type checking at compile time. A dynamically typed language (or program) relies only on dynamic typing, and not static typing. Since when we talk about \emph{typing} we generally mean static typing, we also call dynamically typed programs \emph{untyped}. 

Many statically typed languages possess some facilities for dynamic type checking, blurring the line between static and dynamic languages: \begin{description}
    \item[Static can be dynamic] Java (along with many other object-oriented languages) features \textit{downcasts}, which coerce an object of some class into its subclass. This has to be checked at runtime to preserve safety. It would be entirely possible -- though impractical -- to program in Java using only the \texttt{Object} type and to rely on downcasts for any useful work, essentially circumventing static typing. More glaringly, Java also has reflection facilities, allowing introspection of types of values at runtime. 
    \item[Dynamic can be static] Most dynamically typed languages \emph{could} be given a trivial static type system -- for instance, determining whether a given piece of code is a statement (of type \textsf{stmt}), or expression (of type \textsf{value}). Checking such types would be entirely syntax-directed.
\end{description} 

Furthermore, the line between type checking and other kinds of checks is itself subjective.
Verifying that an index into an array is an integer is obviously known to be type checking (perhaps because it checks the \emph{data type}).
On the other hand, determining whether the index is out-of-bounds is generally thought not to be a type check -- even though it would be in a dependent type system. 

It is thus a difficult problem to both say what dynamic language patterns we should attempt to type statically, and to determine what type safety properties we should ensure. Thus, it is necessary to make some assumptions in order to proceed further.
After all, the space of dynamic programs is extremely large -- but there are only so many interesting patterns hiding within.

\subsection{Taming runtime type checking}
\label{subsec:runtime-type-checking}

Let us distinguish two kinds of runtime type checking -- with the goal of identifying a well-behaving subset: \begin{description}
    \item[Types as data] Firstly, a value's type can be read and itself operated on as a value. For example, both Python and Lua feature a \texttt{type} built-in function which serves this purpose. Since the type becomes a runtime value, it can arbitrarily affect the data and control flow of the program. 
    Similarly, branching on the type (e.g.\@ Python's \texttt{isinstance}) -- a common pattern in literature on \emph{set-theoretic types} -- also treats the type as data. I exclude types as data, as they have the following conseqeuences: \begin{description}
        \item[Lack of \emph{parametricity}] -- accessing the type of a value is legal for any value, i.e. it is of type $\forall \alpha \ldotp \alpha \to \textsf{Type}$. However, since the type can now directly impact the result of the computation, \emph{parametricity} no longer holds: it is no longer the case a polymorphic function performs the same computation in any type instantiation. This stops us from enjoying useful properties -- like theorems for free \cite{theorems-for-free} -- and leads to the second point.
        \item[Lack of \emph{predictability}] -- Subjectively speaking, code using types as data is more complicated and confusing to follow. This is reflected in any attempt to statically analyse them -- even when we limit ourselves to branching on types, it is known that we are limited computationally by the need for \emph{backtracking} \cite{polymorphic-set-theoretic-types}.
    \end{description}
    \item[Types as runtime guardrails] A value's type can instead be consulted only when we perform an operation on it, in order to check whether the operation is legal -- and with an error raised otherwise. This is much closer to the way types behave in statically typed languages.     
    For example, consider a \emph{record} (or \emph{object}) data type, which stores some list of labelled fields, and is commonly featured in dynamic languages. 
    We usually consider the labels of fields present to be part of the record's type.
    Accessing a field of an object requires a (dynamic \emph{or} static) type check for whether it is present in the object.
    
    In fact, viewing types as guardrails -- sources of merely runtime type errors, and not information about a value -- follows the \textbf{duck typing} pattern \cite{duck-typing}. If we expect an object to \texttt{quack()}, then we worry about nothing else but for our program to really \texttt{quack()}. This embodies the principle \textit{``ask for forgiveness, not permission''} -- programs assume that all expected operations are legal.
    Note that -- provided we do not handle errors raised due to illegal operations -- duck typing does not suffer from the same loss of parametricity.
\end{description}
I thus chose to design an approach to static typing which admits programs utilising \textbf{duck typing} -- motivated by the fact that it preserves parametricity. 
We now have to find a way to statically model duck typing.

\subsection{Modelling duck typing}
\label{subsec:duck-models}

Having identified duck typing as a crucial well-behaved pattern in dynamically-typed programs, it remains to find its \emph{static soul} -- a method which admits a corresponding pattern, but can be statically typed.

\subsubsection{Structural subtyping}

Duck typing naturally admits a natural notion of \textbf{subtyping}: if a duck $a$ of type $A$ quacks, and another duck $b$ of type $B$ not only quacks but also walks -- then clearly $b$ can be used in any place $a$ can. A substitution principle holds: the type $B$ supports more operations than $A$, and thus $B$ is a subtype of $A$ -- we shall write denote this $A \sub B$. When speaking of subtyping, we usually refer to its \emph{implicit} variety -- the language does not require an \emph{explicit} annotation every time we treat a type as its supertype.

This is a good time to introduce a distinction between \textbf{nominal} and \textbf{structural} typing \cite{pierce-book}. \begin{description}
    \item[Nominal] Most static type systems in popular programming languages are nominal: types are introduced via a type definition, where they are \emph{named} -- the type is then identified with (e.g.\@ compared by) this name. For example, the type systems in Java, C/C++, and Haskell are predominantly nominal.
    \item[Structural] On the other hand, a structural type system does not pose the requirement for a type to have a name nor a definition. A popular example of a structurally typed language would be TypeScript -- the statically typed dialect of JavaScript. 
\end{description}
Similarly to static and dynamic, nominal and structural typing also lie on a spectrum: few languages feature solely nominal or structural types. A good example of a language with a mix of nominal and structural typing is OCaml (Figure \ref{fig:nominal-and-structural-ocaml}): while records and variants can only be introduced in a \emph{nominal} type definition, we can introduce \emph{structural} type abbreviations. In particular, we have structural versions of records (objects) and variants (polymorphic variants). OCaml modules are structurally typed, too.

\begin{figure}
    \centering
    \begin{subfigure}{.49\textwidth}
    \centering
    \begin{ocaml}
(* record *)
type point = { x : int; y : int }
(* variant *)
type opt = None | Some of int
    \end{ocaml}
    \caption{Nominally typed records and variants.}
    \label{subfig:nominal-ocaml}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.49\textwidth}
    \centering
    \begin{ocaml}
(* object *)
type point = < x : int; y : int >
(* polymorphic variant *)
type opt = [ `None | `Some of int ]
    \end{ocaml}
    \caption{Structurally typed objects and polymorphic variants.}
    \label{subfig:structural-ocaml}
    \end{subfigure}
    \caption{Examples of nominal and structural type definitions in OCaml. Note that the same syntax is used for both nominal type definitions (Figure \ref{subfig:nominal-ocaml}) and structural type abbreviations (Figure \ref{subfig:structural-ocaml}), even though these two kinds of type declarations behave differently in OCaml's type system.}
    \label{fig:nominal-and-structural-ocaml}
\end{figure}

Intuitively, a nominally typed program can be transformed into a structurally typed one, and as such structurally typed programs are inherently more flexible. 
This fundamental idea of \emph{anonymising types} by erasing their names is formally explored in the \textbf{translations} presented in Section \ref{sec:translations}.

We also introduce a similar distinction between nominal and structural \textbf{subtyping}: while in a language like Java subtyping is defined through the inheritance hierarchy (\texttt{class C extends C' \{ ... \}}) -- subtyping is defined on types with specific names -- structural subtyping is instead defined in terms of the structure of the type (though more nuanced definitions exist). For example, structural subtyping naturally arises on records (and, dually, variants) through the following two rules:\footnote{A traditional formal treatment is given by \textcite{pierce-book}. In this dissertation -- to bring us closer to algebraic subtyping, the subject of Chapter \ref{algebraic-subtyping} -- we use a slightly different approach.}
\begin{description}
    \item[Width subtyping] A record is a subtype of another if it has more fields and the other are compatible, e.g.: $$ \{ \mathrm{foo} : \mathrm{int}, \mathrm{bar} : \mathrm{string} \} \sub \{ \mathrm{foo} : \mathrm{int} \} $$
    \item[Depth subtyping] A record is a subtype of another if its respective fields are subtypes, e.g.:
    $$ \{ \mathrm{foo}: \mathrm{nat}, \mathrm{bar}: \mathrm{string} \} \sub \{ \mathrm{foo}: \mathrm{int}, \mathrm{bar}: \mathrm{string} \} $$
\end{description}
We formalise this in the type system for the record calculus -- Featherweight Lua -- in Section~\ref{subsec:featherweight-lua}.

Clearly, \textbf{structural subtyping} is most relevant for modelling duck typing: most dynamically typed programs will not feature type definitions.\footnote{A note-worthy exceptions would be OOP-style class definitions, present in e.g.\@ Python.} I am motivated by modelling objects in dynamic languages, following the tradition of \textcite{cardelli-multiple-inheritance}.

I chose structural subtyping as the direction for my thesis -- we briefly consider two possible alternatives in the following subsections.

\subsubsection{Row polymorphism}

\begin{figure}
    \centering
    \begin{tabular}{c}
    \begin{ocaml}
let f = function 
    | `None -> `Unit 
    | `Some x when x mod 2 = 0 -> `Pair (x / 2, x / 2) 
    | `Some x -> `Single x
(* 
val f : [< `None | `Some of int ] 
     -> [> `Pair of int * int | `Single of int | `Unit ]
*)
    \end{ocaml}
    \end{tabular}
    \caption{Example of row polymorphism in OCaml using polymorphic variants, annotated with its (inferred) most general type. \texttt{<} and \texttt{>} stand for row type variables in a closed and open variant, respectively.}
    \label{fig:ocaml-row-polymorphism}
\end{figure}

There is a common folklore trick for replacing subtype polymorphism in a system with parametric polymorphism by an appropriate form of parametric polymorphism \cite{structural-subtyping-as-parameric-polymorphism}. For example, a function of type $\top \to \mathrm{int}$ -- featuring a top type $\top$, the supertype of any type -- could equivalently be given the type scheme $\forall \alpha \ldotp \alpha \to \mathrm{int}$, since $\alpha$ can be instantiated to any argument type.
Row polymorphism \cite{remy-records}, introduced by \textcite{wand-rows} -- and sometimes called structural polymorphism \cite{simple-structural-polymorphism} -- can be seen as an application of this trick to structural record and variant types: we introduce \emph{row type variables} that stand for \enquote{the rest of the record} (for which the width subtyping rule applies in records with structural subtyping).

% https://ocaml.org/papers
We do not consider a technical explanation of row polymorphism as it is outside the scope of this thesis. It is worth noting that OCaml's structurally typed objects \cite{objective-ml} and polymorphic variants \cite{polymorphic-variants} -- as exemplified in Figure \ref{subfig:structural-ocaml} -- are typed using a form of row polymorphism, which features keeps row variables limited sufficiently to be kept implicit \cite{objective-ml}. OCaml also supports \textbf{explicit} (super)type coercions, adding a limited form of explicit structural subtyping -- managing the limitations of the row polymorphism design. 
An example application of row polymorphism in OCaml is given in Figure \ref{fig:ocaml-row-polymorphism}.\todo[color=cyan]{example}

The relative power of structural subtyping and row polymorphism -- as extensions on parametric polymorphism -- is unclear.
% , and building systems based on row polymorphism is a viable alternative -- though possibly limited in the context of types for which rows are not clearly helpful in modelling notions of subtyping. 
There is some recent work exploring the relationship between the two \cite{disjoint-polymorphism, structural-subtyping-as-parameric-polymorphism}. However, systems with row polymorphism tend to grow more complex than ones with subtyping -- but they have historically been a more straightforward extension of ML-like type systems.

\subsubsection{Set-theoretic types}

\todo{write}

\section{Languages}
\label{sec:languages}

\todo{write}

\subsection{Featherweight Lua}
\label{subsec:featherweight-lua}

\newcommand{\erased}[1]{\textcolor{red}{#1}}

\begin{figure}
    \centering
    \input{Sources/2-Figures/FL-syntax}
    \caption{Syntax of Featherweight Lua.}
    \label{fig:featherweight-lua-grammar}
\end{figure}

\begin{figure}
    \centering
    \input{Sources/2-Figures/FL-subtyping}
    \caption{Declarative definition of the subtyping relation $\sub$ in Featherweight Lua, including on field types $\phi$. $\mathcal L(\tau)$~stands for the set of labels $\ell$ in the record type $\tau$. We define projection on record types,~$\flproj{\tau}{\ell} = \phi.$}
    \label{fig:featherweight-lua-subtyping}
\end{figure}

\begin{figure}
    \input{Sources/2-Figures/FL-typing}
    \caption{Typing rules for the statically typed fragment of Featherweight Lua.}
    \label{fig:featherweight-lua-typing}
\end{figure}

\begin{figure}
    \centering
    \input{Sources/2-Figures/FL-Lua}
    \caption{Embedding of Featherweight Lua expressions $e$ into Lua programs $\lua e$. The embedding makes use the use of the functional \textsf{update} for tables, defined in Lua code as part of a preamble. \\
    This is only a sketch of the translation -- for instance, any let-bindings should be extracted as separate statements, as Lua does not have binding expressions.}
    \label{fig:featherweight-lua-embedding}
\end{figure}

\todo{write}

\subsubsection{Embedding in Lua}
Featherweight Lua is, notionally, a subset of a widely known dynamically typed language: Lua \cite{lua54}.
Lua's core data structure is the \emph{table}, which we replicate -- though with strictly less power (without dynamic key access, Lua's ``metatables'', etc.) -- as FL's records. 
Lua also features first-class functions.
A key distinction between FL and Lua is the former's lack of mutability. 

To show the compatibility of FL with its namesake, I sketch a compositional embedding of FL into Lua in Figure \ref{fig:featherweight-lua-embedding}, claiming it preserves semantics.

\subsection{Featherweight Java}
\label{subsec:featherweight-java}

\todo{write}

\section{Translations: Anonymising Types}
\label{sec:translations}

\todo{write}

\begin{figure}
    \centering
    \input{Sources/2-Figures/FL-FJ}
    \caption{The translation from Featherweight Java into the statically typed fragment of Featherweight Lua. We have translations for expressions $\denot{-} = e$ and types $\denoty{-} = \tau$.}
    \label{fig:translation}
\end{figure}

\subsection{Construction}

\todo{write}

\subsection{Correctness}

We now state some theorems about the correctness of the translation.

\begin{theorem}[Preservation of typing]
    If $\Gamma \vdash \fj e : \fj C$, then $\denoty{\Gamma} \vdash \denot{\fj e} : \denoty{\fj C}$. 
\end{theorem}

\begin{theorem}[Preservation of semantics]
    If $\cdot \vdash \fj e : \fj C$ and $\fj e \rightarrow^* \fj v$, then $\denot{\fj e} \rightarrow^* \denot{\fj v}$.
\end{theorem}

In the statement of these theorems, we implicitly assume a well-typed class table $\mathrm{CT}$ (as defined by \textcite{featherweight-java}) -- it is necessary both for types and semantics.

Note that, as pointed out by \textcite{inheritance-subtyping}, inheritance is \emph{not} subtyping -- it does not follow that $\denoty{\fj C} \sub \denoty {\fj C'}$ for any class $\fj C$ that $\fj{extends C}'$.

\subsection{Consequences}

Existence of the FL-FJ translations proves two key notions along different axes: \begin{description}
    \item[Nominal-structural] Structural types are a more flexible typing discipline, as nominal types can be straightforwardly erased from simply-typed programs.
    \item[Static-dynamic] A structurally typed calculus remains useful when we consider its untyped variety, and its statically typed fragment captures some -- but not all -- programs that do not go wrong.
\end{description}
\todo{diagram?}

\section{Summary}

I have identified \textbf{duck typing} as a well-behaved pattern in dynamically typed programs, and \textbf{structural subtyping} as its appropriate model suitable for constructing expressive static type systems. I motivate this choice by presenting translations and embeddings for a pair of calculi: the nominally typed Featherweight Java, and the structurally typed Featherweight Lua. These formally reinforce intuitive beliefs about the static-dynamic and nominal-structural axes of type systems, and serve as groundwork for the thesis.

Though this dissertation does not explore the application of structural subtyping to statically typing \emph{specific} dynamic languages (e.g.\@ as part of a \emph{gradual} type system \cite{gradual-typing-for-objects}), it contributes elements of a framework for doing so and motivates the application of structural subtyping for this purpose. In the next chapter, we develop a type inference framework for general languages featuring structural subtyping.

% It has by now become evident that the aim of this thesis is not to implement a new system for typing dynamic languages directly. Instead, I identify and develop general approaches that show potential to be used for this purpose. Furthermore, they can inform the design of (possibly domain-specific) languages that can admit more flexible type systems.