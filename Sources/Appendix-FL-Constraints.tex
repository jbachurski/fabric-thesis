\chapter{Type inference for Featherweight Lua}
\label{extra:fl-constraints}

This appendix gives technical details necessary to instantiate \inference{} to perform type inference for Featherweight Lua programs.

\section{Lattice of types}

For simplicity, I denote instantiated type constructors $K[\overline \tau]$ with $\tau$.
The lattice of type constructors in FL is defined as such:
\begin{align*}
    \tau \cjoin \top &= \top \\ 
    \tau \cjoin \bot &= \tau \\
    (\tau_1 \to \tau_1') \cjoin (\tau_2 \to \tau_2') &= (\tau_1 \cmeet \tau_2) \to (\tau_1' \cjoin \tau_2') \\ 
    \flext{\overline{\ell: \phi_\ell}}{\phi} \cjoin \flext{\overline{\ell': \phi_\ell'}}{\phi'} &= \flext{\overline{\ell: \phi_\ell \cjoin \phi_\ell'}}{\phi \cjoin \phi'}
\end{align*}
with $\meet$ defined dually (by swapping $\cjoin$ with $\cmeet$, and $\top$ with $\bot$). It can be straightforwardly proven this definition yields a distributive lattice.

\section{Constraint generation}
\label{extra-sec:fl-cstrs}

I present the full constraint generation for FL.

$$ \boxed{\cstr{\Gamma}{e}{\tau} = c} $$
\begin{align*}
\cstr{\Gamma}{x}{\tau} &= \Gamma(x) \sub \tau 
&\textsc{Var} \\
\cstr{\Gamma}{\fllet{x}{e'}{e}}{\tau} &= \exists \tau' \ldotp \cstr{\Gamma}{e'}{\tau'} \und \cstr{\Gamma, e' : \tau'}{e}{\tau}
&\textsc{Let} \\
\cstr{\Gamma}{\fllam x e}{\tau} &= \exists \tau', \tau'' \ldotp \cstr{\Gamma, x : \tau'}{e}{\tau''} \und \tau \sub \tau' \to \tau''
&\textsc{Lam} \\
\cstr{\Gamma}{e\,e'}{\tau} &= \exists \tau' \ldotp \cstr{\Gamma}{e'}{\tau'} \und \cstr{\Gamma}{e}{\tau' \to \tau}
&\textsc{App} \\
\cstr{\Gamma}{\flrec{\overline{\ell = e_\ell}}}{\tau} &= \exists \overline{\tau_\ell} \ldotp \overline{\cstr{\Gamma}{e_\ell}{\tau_\ell}} \und \flext{\overline{\ell : \tau_\ell}}{\flftop} \sub \tau
&\textsc{Cons} \\
\cstr{\Gamma}{\sproj{e}{\ell}}{\tau} &= \cstr{\Gamma}{e}{\srecordtype{\ell : \tau}}
&\textsc{Proj} \\
\cstr{\Gamma}{\flext{\ell = e_\ell}{e}}{\tau'} &= \exists \tau, \tau_\ell \ldotp \cstr{\Gamma}{e}{\tau} \und \cstr{\Gamma}{e_\ell}{\tau_\ell} \und &\textsc{Ext} \\ 
&\qquad\quad\und \tau \sub \flext{\ell : \flabsent}{\flftop} \und \mathrm{forget}_\ell(\tau) \meet \flext{\ell : \tau_\ell}{\flftop} \sub \tau' &
\end{align*}
It also types record extension (\textsc{Ext}) by applying the $\mathrm{forget}$ homomorphism (considered throughout examples in Section \ref{sec:morphisms}) -- but in doing so it breaks Dolan's polarity restriction (Section \ref{subsec:algebraic-subtyping-background}) and involves a homomorphism application (Section \ref{sec:morphisms}).

\section{Correctness of homomorphisms}

I now make precise the technical development of homomorphisms for typing extensible records, as I presented it in Section \ref{sec:morphisms}.

\subsection{Language}
    % \item Sketch that they are indeed homomorphisms.

We now make precise the language of homomorphisms $\morph$ for FL. A key aspect is that not only need morphisms $\mathrm{forget}_\ell$ (denoted here as $[\ell \mapsto \flftop]$) and $\mathrm{free}_\ell$ ($[\ell \mapsto \flfbot]$), but also their compositions. We define $\morph$ as such:
$$ \morph ::= \mathrm{id} \mid \morph \circ [\ell \mapsto \flftop] \mid \morph \circ [\ell \mapsto \flfbot]  $$
and, as required, define application on type constructors:
\begin{align*}
    \morph(\top) &= \top \\ \morph(\bot) &= \bot \\ 
    \morph(\tau \to \tau') &= \tau \to \tau' \\
    \id \left( \flext{\overline {\ell : \phi_\ell}}{\phi} \right) &= \flext{\overline {\ell : \phi_\ell}}{\phi} \\
    (\morph \circ (\ell \mapsto \phi_\ell)) \left( \flext{\overline {\ell : \phi_\ell}}{\phi} \right) &= \morph \left( \flext{\overline {\ell : \phi_\ell}, \ell : \phi_\ell}{\phi} \right)
\end{align*}
There are some difficulties here regarding multiple updates at the same field $\ell$. We will establish the convention that if a field $\ell$ occurs twice in a list of assignments (as it might in $\morph$ or in a record type), then we ignore the one that occurs first.

\subsection{Laws}

We now check that our definition of $\morph(\tau)$ indeed satisfies the homomorphism laws (Fig. \ref{fig:morphism-laws}).

\begin{proof}
Clearly, each component of $\morph$ operates \emph{pointwise}, and identically on non-record types. Thus, we only check here that the homomorphism laws apply at singleton record types of form $\flrec{\ell : \phi}$, carrying the rest of the fields through implicitly. 

Laws for top and bottom are given by definition, so we check meets are preserved (joins are symmetric). By induction over the structure of $\morph$:
\begin{align*}
\id \left( \flrec{\ell : \phi'} \right) \meet \id \left( \flrec{\ell : \phi''} \right) &= 
\flrec{\ell : \phi' \meet \phi''} \\ &= \id \left( \flrec{\ell : \phi'}  \meet \flrec{\ell : \phi''} \right) \\
(\morph \circ [\ell \mapsto \phi])\left( \flrec{\ell : \phi'} \right) \meet (\morph \circ [\ell \mapsto \phi])\left( \flrec{\ell : \phi''} \right) &= \morph \left( \flrec{\ell : \phi} \right) \meet \morph \left( \flrec{\ell: \phi} \right) = \morph \left( \flrec{\ell: \phi} \right) \\ 
&= (\morph \circ [\ell \mapsto \phi])\left( \flrec{\ell : \phi' \meet \phi''} \right) \\ 
&= (\morph \circ [\ell \mapsto \phi])\left( \flrec{\ell : \phi'} \meet \flrec{\ell : \phi''} \right)
\end{align*}    
\end{proof}

\needspace{6em}
\subsection{Adjoints}
    % \item Sketch proof that adjoint pairs work.

As part of the example given in Section \ref{subsec:signature-morphisms}, I gave the table of adjoints for $\mathrm{free}_\ell$ and $\mathrm{forget}_\ell$. I now show that these indeed fulfil the necessary laws. We focus on $\mathrm{forget}_\ell$ ([$\ell \mapsto \flftop$]), and analogously to the previous proof we can use pointwise reasoning (with respect to both the fields and the composition of morphisms). Proofs for $\mathrm{free}_\ell$ ([$\ell \mapsto \flfbot$]) follow exactly analogously.

The key idea behind the proofs is that an application of $\mathrm{free}$/$\mathrm{forget}$ sends the field specifically to top and bottom, leading to either a constraint being always satisfied along the considered field $\ell$, or only ever being satisfied when the field is exactly $\flfbot$/$\flftop$.

Firstly, I prove that left-adjoints work:
$$ \tau' \sub \underbrace{[\ell \mapsto \flftop]}_\morph(\tau'') \quad\cstreq\quad \underbrace{[\ell \mapsto \flfbot]}_{\ladj \morph}(\tau') \sub \tau'' \und \underbrace{\tru}_{\ladjrest \morph(\tau')} $$
\begin{proof}
For brevity, I will only consider $\tau' = \flrec{\ell : \phi'}$ and $\tau' = \flrec{\ell : \phi''}$:
$$ \underbrace{\flrec{\ell : \phi'}}_{\tau'} \sub [\ell \mapsto \flftop] \left( \smash{\underbrace{\flrec{\ell : \phi''}}_{\tau''}} \right) = \flrec{\ell : \flftop} \quad\cstreq\; \tru \;\cstreq\quad \flrec{\ell : \flfbot} = [\ell \mapsto \flfbot] \left( \smash{\underbrace{\flrec{\ell : \phi'}}_{\tau'}} \right) \sub \underbrace{\flrec{\ell : \phi''}}_{\tau''} $$
the general case follows by carrying through the other fields of both records.
\end{proof}

Secondly, I prove right-adjoints also work:
$$ \underbrace{[\ell \mapsto \flftop]}_\morph(\tau') \sub \tau'' \quad\cstreq\quad  \tau' \sub \underbrace{\id}_{\radj \morph}(\tau'') \und \underbrace{\flext{\ell : \flftop}{\flfbot} \sub \tau''}_{\ladjrest \morph(\tau'')} $$
\begin{proof}
Analogously as before:
$$ \flrec{\ell : \flftop} =  [\ell \mapsto \flftop] \left( \smash{\underbrace{\flrec{\ell : \phi'}}_{\tau'}} \right) \sub \underbrace{\flrec{\ell : \phi''}}_{\tau''} \quad\cstreq\quad \flftop = \phi'' \quad\cstreq\quad \flext{\ell : \flftop}{\flfbot} \sub \flrec{\ell : \phi''}  $$
as this is satisfied only iff $\flftop = \phi''$, we can add the always-satisfied constraint $\tau' \sub \tau''$ ($\phi' \sub \phi''$), yielding:
$$ \underbrace{\flrec{\ell : \phi'}}_{\tau'} \sub \mathrm{id} \left( \smash{\underbrace{\flrec{\ell : \phi''}}_{\tau''}} \right) \und \flext{\ell : \flftop}{\flfbot} \sub \underbrace{\flrec{\ell : \phi''}}_{\tau''} $$
\end{proof}

This shows that the described homomorphisms are indeed well-behaved in constraint solving.

\needspace{6em}
\subsection{Record extension}
    % \item Sketch that rule using homomorphisms is equivalent to the usual rule.

Lastly, I sketch the equivalence of the rules $\textsc{FL-Typ-Ext}$ (quantifying over record types) and $\textsc{FL-Typ-HExt}$ (applying $\mathrm{forget}_\ell$). For completeness, they are given below:
$$
\irule{FL-Typ-Ext}
    {\Gamma \vdash e : \flext{\ell' : \flabsent, \overline{\ell : \phi_\ell}}{\phi} \quad \Gamma \vdash e' : \tau'}
    {\Gamma \vdash \flext{\ell' = e'}{e} : \flext{\ell' : \tau', \overline{\ell : \phi_\ell}}{\phi}}
\quad 
\irule{FL-Typ-HExt}{\Gamma \vdash e : \tau \meet \flext{\ell' : \flabsent}{\flftop} \quad \Gamma \vdash e' : \tau'}{\Gamma \vdash \flext{\ell' = e'}{e} : \mathrm{forget}_{\ell'}(\tau) \meet \flext{\ell' : \tau'}{\flftop}}
$$
\begin{proof}
    Firstly, note that the assumptions of the two rules are equivalent. The only difference is in the constraint on $e$ -- to see that the two are equivalent, notice that $\flext{\ell' : \flabsent, \overline{\ell : \phi_\ell}}{\phi}$ are exactly the types of form $\tau \meet \flext{\ell : \flabsent}{\flftop}$ for some $\tau = \flext{\overline{\ell : \phi_\ell}}{\phi}$ (unless $\ell : \flfbot$, in which case the assumption also follows).

    Since assumptions of the two rules are equivalent, it remains to show their consequences are as well. However, this also follows straightforwardly via the reasoning presented in the FL example given in Section~\ref{sec:morphisms} -- $\mathrm{forget}_\ell(\tau) \meet \flext{\ell : \phi}{\flftop}$ sends the field $\ell$ in $\tau$ to $\phi$. 
\end{proof}

Is is then straightforward to see that constraint generation (Sec. \ref{extra-sec:fl-cstrs}) in the case \textsc{Ext} is correct, as it follows the form of the corresponding rule.