\newenvironment{example}{%
\begin{tcolorbox}[%
    colback=blue!5!white,% 
    colframe=blue!60!black,%
    title=\textsc{Example}%
]%
}{%
\end{tcolorbox}%
}

\chapter{Constraint-Based Algebraic Subtyping}
\label{algebraic-subtyping}

Convenience of programming with dynamic typing is partially thanks to the absence of type annotations. 
This comfort comes at a price -- we cannot ensure safety guarantees at compile-time. 
The aim of this thesis is to statically type languages with similar flexibility in mind. As such, we need to recover static types in the absence of annotations -- to have \emph{implicit typing} \cite{remy-record-inference}. This is the mission statement of \textbf{type inference} \cite{tapl}.

In this chapter, I explore the problem of type inference for languages with structural subtyping. In doing so, I follow Dolan's seminal thesis on \textbf{algebraic subtyping} -- a type inference technique in the presence of subtyping and (bounded) parametric polymorphism. Specifically, I contribute the following:
\begin{itemize}
    \item A \textbf{constraint-based type inference framework} -- \inference{} -- based on the current state-of-the-art in algebraic subtyping. My framework does not fix specific type or expression languages -- it sets out some requirements for them (the \textit{signature}) and operates on an intermediate \emph{constraint language}. The constraint-based description is simple and direct, though formal and close to the implementation. The framework is a step towards understanding when we can apply algebraic subtyping in practice.
    \item An extension of algebraic subtyping that supplements the type language with \textbf{type algebra homomorphisms}, described for \inference{}. Using this extension, I give a method to statically type extensible records using algebraic subtyping -- a novel alternative to row polymorphism. Thus, I can infer types for Chapter \ref{static-soul}'s Featherweight Lua using \inference{}.
\end{itemize}

We begin with background on type inference, including our constraint-based setting and a review of the developments in algebraic subtyping (Section \ref{sec:ch3background}). The rest of the chapter's contents are the description of the framework. Firstly, in Section \ref{sec:signature} I give a description of \inference{}'s \textbf{signature} -- the requirements on the source type language. Afterwards, in Section \ref{sec:constraints} I explain \textbf{constraint solving} in \inference{}, and show the homomorphism extension in Section \ref{sec:morphisms}. Finally, I state and conjecture the correctness theorems of the framework in Section \ref{sec:correctness}. 

\begin{example}
    To ease understanding, the technical text of this chapter will be interleaved with boxes like this one, containing examples using Featherweight Lua (with some described extensions).
\end{example}

\section{Background}
\label{sec:ch3background}

Since this chapter concerns describing algebraic subtyping in the framework of constraint-based type inference, I explain these two concepts. We also set up the setting of the type inference problem we consider. 

\subsection{Type inference}
\emph{Type inference} (also called \emph{type reconstruction}), at its core, concerns determining the type $\tau$ of a given expression $e$ under an environment $\Gamma$ -- as given by the \emph{typing judgement} $\Gamma \vdash e : \tau$.

\paragraph{Polymorphism \& type schemes} Type inference is straightforward in a \emph{simply-typed} setting. This is often unsatisfactory -- for instance, $\mathrm{id} =  \lambda x \ldotp x$ has type $\tau \to \tau$ for any type $\tau$, but this is inexpressible at the object-level.
This leads us to \textbf{parametric polymorphism}, where types contain type variables (denoted $\alpha, \beta, \gamma, \dots$), which can stand for any type. 
In this setting, expressions are not only given a type $\tau$, but also a \textbf{type scheme} $\sch$ which can be \textbf{instantiated} to a type $\tau$ (written $\sch \models \tau$). We define a judgement $\Gamma \vdash e : \sch$ for ascribing a type scheme (\eg{} $\cdot \vdash \mathrm{id} : \forall \alpha \ldotp \alpha \to \alpha$), checking the expression is typed at any instantiation:
$$ \dfrac{\forall \tau \ldotp\; \left( \sch \models \tau \implies \Gamma \vdash e : \tau \right)}{\Gamma \vdash e : \sch} $$

The classical solution to type inference under parametric polymorphism is through the Hindley-Milner (HM) type system, which relies on unifications to compute most-general type substitutions \cite{essence-of-ml-type-inference, tapl}. It underlies type systems of languages in the ML family.

In this chapter, we will consider type inference in the presence of $F_\sub$-style \textbf{bounded} parametric polymorphism (in essence, \emph{bounded quantification} of \textcite{bounded-quantification}). Our type schemes $\sch$ have a form reminiscent of Java-style generics \cite{generic-java, simple-sub}:\footnote{Writing $\tau^+$ and $\tau^-$ for lower/upper bounds matches the \emph{polarity restriction} (Section~\ref{subsec:algebraic-subtyping-background}). In \inference{}, $\tau^+$ and $\tau^-$ stand for $\tau$.}
$$ \sch ::= \forall \, \overline{\tau^+ \sub \alpha \sub \tau^-} \ldotp \tau $$
where the body $\tau$ of $\sch$ must not contain unquantified type variables, and omitted lower/upper bounds are presumed $\bot$/$\top$. 
Instantiation $\models$ derives from a type assignment $\psi ::= \cdot \mid \psi, \tau/\alpha$, which satisfies the bounds for each free type variable $\alpha$. Writing $[\psi]\tau$ for a substitution in $\tau$ under $\psi$, we define:
$$ \dfrac{\overline{[\psi]\tau_\alpha^+ \sub \substx{\psi} \alpha \sub [\psi]\tau_\alpha^-}}{\left( \forall\, \overline{\tau_\alpha^+ \sub \alpha \sub \tau_\alpha^-} \ldotp \tau \right) \models \substx{\psi}{\tau}} $$
\begin{example}
    We extend FL with bounded parametric polymorphism from here onwards, so $\tau ::= \cdots \mid \alpha$. 

    Consider $e = \fllam x\, \flproj{x}{\mathrm{foo}}$. Then we have both 
    \vspace{-0.5em}
    $$ \cdot \vdash e : \forall \alpha, (\beta \sub \flrec{\mathrm{foo} : \alpha}) \ldotp \beta \to \alpha  \quad \text{and} \quad \cdot \vdash e : \smash{\underbrace{\forall \alpha \ldotp \flrec{\mathrm{foo} : \alpha} \to \alpha}_\sch} $$
    and that $\sch \models \flrec{\mathrm{foo} : \top} \to \top$ at $\top/\alpha$.
    Possibility of multiple type schemes points us to \emph{type scheme simplification} -- here, we obtain the second type scheme by \emph{inlining} the bound on $\beta$ in the first. We discuss this important topic in Section  ~\ref{subsec:simplification}.
\end{example}

We allow bounds $\tau_\alpha^+$/$\tau_\alpha^-$ in type schemes to refer to other type variables, naturally leading us to \emph{recursive types}.
Specifically, we will consider type systems with \textbf{equirecursive types} -- infinite terms in the type language.\footnote{As opposed to isorecursive types, which are finite and (un)folded explicitly \cite{tapl}.} We will write $\rec \alpha \tau$ for a type in which $\alpha$ is equal to the entire type, \ie{} $\rec \alpha  \tau = \rec \alpha [\rec \alpha \tau/\alpha] \tau$.
\begin{example}
    We further extend FL with equirecursive $\mu$ types. 
    The type $\tau = \rec \alpha \top \to \alpha$ corresponds to the infinite type $\top \to (\top \to (\top \to \cdots)))$. Given $\cdot \vdash e : \tau$ and $\cdot \vdash e' : \top$ we have $\cdot \vdash e\,e' : \tau$. Hence, $\tau$ is the type of a function that takes an unbounded number of arguments.
\end{example}

We define two more type scheme-related concepts: \emph{subsumption} and \emph{principality} (minimality). We define that $\sch'$ \textbf{subsumes} $\sch$, written $\sch \subsume \sch'$:
$$ \sch \subsume \sch' \iff \forall \tau \ldotp (\sch \models \tau \impliedby \sch' \models \tau) $$
meaning that $\sch$ admits all the types that $\sch'$ does. 
Based on subsumption, we define the \textbf{principal} type scheme $\sch$ for an expression $e$ as one that subsumes all its other type schemes $\sch'$ (it is minimal\footnote{Taking type schemes $\sch$ for which $\Gamma \vdash e : \sch$, the type scheme minimal under $\subsume$ subsumes them all, admitting the most types.}), \ie{}:
$$ \sch\text{ principal} \iff \forall \sch' \ldotp \left( \Gamma \vdash e : \sch' \implies \sch \subsume \sch' \right) $$
Subsumption can be seen as a generalisation of subtyping to type schemes.
\begin{example}
Consider the following type schemes:
$$    \sch^+ = \forall \alpha, \beta \ldotp \alpha \to \beta
\quad \sch' = \forall \beta \ldotp \flrec{} \to \beta 
\quad \sch'' = \forall \alpha \ldotp \alpha \to \flrec{} 
\quad \sch^- = \flrec{} \to \flrec{} $$
Then $\sch^+ \subsume \sch' \subsume \sch^-$ and $\sch^+ \subsume \sch'' \subsume \sch^-$, but neither $\sch' \subsume \sch''$ nor $\sch'' \subsume \sch'$. 

Among the four, $\sch^+$ is minimal with respect to subsumption.
\end{example}

\paragraph{Constraint-based approach} While type schemes let us describe the \emph{result} of type inference, we can use \textbf{constraints} to describe type inference \emph{problems}. To this end, we follow the approach outlined in \citetitle{essence-of-ml-type-inference} by \textcite{essence-of-ml-type-inference} (\textcite[Chapter~10]{adv-tapl}).

This chapter will focus on constraint solving in the presence of subtyping, so we give an adequately simple constraint language in Figure \ref{fig:constraints} with only one predicate -- subtyping $\tau \sub \tau$, where types $\tau$ may contain type variables. We also feature constraint conjunction $c \und c$ and allow introducing existential variables $\exists \alpha \ldotp c$. The constraint satisfaction judgement $\psi \vdash c$ defined\footnote{... in the style of \textcite{constraint-based-freeze-ml}, with \emph{delayed} substitution: notice $\psi \vdash c \iff \cdot \vdash \substx \psi c$.} in Figure \ref{fig:satisfaction} gives a semantics to this syntax, specifying what variable assignments $\psi$ satisfy a given constraint $c$. 
% In constraint solving nomenclature, we are dealing with a cylindric constraint system \cite{constraint-based-hm}. 

\begin{example}
    Take $c = \tru \und \left( \exists \beta \ldotp \alpha \sub (\beta \to \flrec{}) \right)$. Then: 
    $$ (\flrec{} \to \flrec{})/\alpha \vdash c \quad\text{and}\quad \bot/\alpha \vdash c$$
\end{example}

\begin{figure}
    \centering
    \begin{align*}
        \graintro c 
        \tru
        & \text{(always-true)}
        \graitem
        \fals
        & \text{(always-false)}
        \graitem
        \tau \sub \tau 
        & \text{(subtyping)}
        \graitem
        c \und c
         & \text{(conjunction)}
        \graitem 
        \exists \alpha \ldotp c
        & \text{(existential)}
    \end{align*}
    \caption{Syntax of constraints $c$ used in this chapter.}
    \label{fig:constraints}
\end{figure}

\begin{figure}
    \centering
    $$
    \irule{CTrue}{}{\psi \vdash \tru}
    \quad
    \irule{CSub}{\substx \psi \tau \sub \substx \psi \tau'}{\psi \vdash \tau \sub \tau'}
    \quad
    \irule{CAnd}{\psi \vdash c \quad \psi \vdash c'}{\psi \vdash c \und c'}
    \quad 
    \irule{CExist}{\psi, \tau/\alpha \vdash c}{\psi \vdash \exists \alpha \ldotp c}
    $$
    \caption{Constraint satisfaction judgement $\psi \vdash c$, defined for a type variable assignment $\psi$ and constraint $c$. Note that $\psi \vdash \fals$ is false for any $\psi$ ($\fals$ signals failure -- type errors), and $\psi \vdash \tru$ is true for any $\psi$. We~use the Barendregt convention to avoid accidental capture in \textsc{CExist}, and abbreviate $\overline {\exists \alpha}$ to $\exists \overline{\alpha}$.}
    \label{fig:satisfaction}
\end{figure}

\needspace{6em}
To construct a type inference problem as a constraint $c$ from an expression $e$ in the source language and its expected type $\tau$, we use \textbf{constraint generation} $\cstr{\Gamma}{e}{\tau}$. Crucially, it must agree with typing:\footnote{Some presentations modify the type-scheme judgement to involve constraints (like $c; \Gamma \vdash e : \sch$) \cite{essence-of-ml-type-inference} or focus on constraint entailment instead of satisfaction \cite{constraint-based-hm}. For simplicity, we work with instantiations $\psi$, closer to \eg{} \cite[Section 3.4]{constraint-based-freeze-ml}.}
$$ \psi \vdash \cstr{\Gamma}{e}{\tau} \iff \substx{\psi}\Gamma \vdash \substx{\psi}{e} : \substx \psi \tau $$
Inferring types, we do not know the specific type $\tau$ -- but we can introduce as a free variable $\alpha$ and take $\cstr{\Gamma}{e}{\alpha}$. Analogously, if an expression contains `type holes' (\eg{} unannotated function parameters) these can be filled with type variables and constrained appropriately \cite{tapl}.

\begin{example}
    Consider $e = \fllam{x: \alpha} \flproj{x}{\mathrm{quack}}\,\{\}$. We might generate the constraint $c$ for $e$:
    $$ c = \cstr{\cdot}{e}{\tau} = \exists \beta \ldotp (\alpha \sub \flrec{\mathrm{quack}: \beta}) \und \left( \exists \gamma \ldotp (\beta \sub \flrec{} \to \gamma) \und (\gamma \sub \tau) \right) $$
    FL constraint generation is defined in Appendix \ref{extra:fl-constraints}. Notice subtyping constraints follow dataflow~\cite{mlsub}.
    Later, we show $c$ can be \emph{rewritten} to $\exists \beta \ldotp (\flrec{\mathrm{quack} : \flrec{} \to \beta} \to \beta) \sub \tau$, and hence 
    $\cdot \vdash e : \forall \beta \ldotp \flrec{\mathrm{quack} : \flrec{} \to \beta} \to \beta$.
\end{example}

Lastly, we define \emph{constraint equivalence} $\cstreq$:
$$ c \cstreq c' \iff  \forall \psi \ldotp \; (\psi \vdash c \iff \psi \vdash c') $$

The description of \inference{} can be used to instantiate an existing constraint-based framework like $\mathrm{HM}(X)$ of \textcite{constraint-based-hm}. Hence, we do not consider let-polymorphism (like \textcite{dolan-thesis} and \textcite{simple-sub} do for algebraic subtyping), which $\mathrm{HM}(X)$ could yield \enquote{for free}. We focus on \textbf{resolution of subtyping constraints}, and not more advanced constraints (like local type assumptions \cite{outside-in}).

% It is worth noting here that this treatment of type inference is a bit different to the common Hindley-Milner type inference. There, we reason about unification and most general substitutions, but are also limited to an equality (rather than subtyping) predicate in constraints. Dolan's \emph{algebraic subtyping} (which we expand on in the next section) also reasoned about \emph{biunification} \emph{bisubstitutions}, more recent work moved towards a constraint-based approach, and this is the one we shall follow.

\subsection{Algebraic subtyping}
\label{subsec:algebraic-subtyping-background}

Combining bounded parametric polymorphism with both principal type inference and decidability of type scheme subsumption historically proved to be a difficult problem, leading to distrust in implicit subtyping as part of language design \cite{mlstruct} -- so much so that research would avoid subtyping due to its problematic interaction with type inference (see \eg{} \cite[Section~3.5]{linear-haskell}). Seminal work in the area is by \textcite{pottier-thesis}, who set out a framework for type inference under subtyping, but did not reach a satisfactory solution. The problem was ultimately resolved by \textcite{dolan-thesis} in his thesis.

\needspace{5em}
\subsubsection{Original work (Dolan)}
\label{subsubsec:dolan}

There are two (closely linked) core principles guiding Dolan's approach \cite[Section~1.3]{dolan-thesis}: \begin{description}
    \item[Extensibility] Dolan identified that a core problem in previous solutions was closed-world reasoning on the language of types \cite[Section~1.3.1]{dolan-thesis}. Thus, he requires \emph{extensibility}: that for considered type systems, extending their type language preserves typing of programs.
    \item[Algebra before syntax] Dolan found that the common syntactic approach to defining the type language has neglected ensuring subtyping is well-behaved \cite[Section~1.3.2]{dolan-thesis}. Thus, he argued for an algebraic construction of the type language. Extensibility motivated many algebraic properties \cite[Section~2.1.5]{dolan-thesis}.
\end{description}
Using these principles and a careful formal treatment relying on abstract algebra, Dolan invented \mlsub{} -- a statically typed language with support for structural subtyping, building on core ML, and boasting ML-style type inference with bounded parametric polymorphism and decidable type scheme subsumption.

Two assumptions underlie \mlsub{} which enable its properties: subtyping forming a \textbf{distributive lattice}, and the \textbf{polarity restriction} of the type language. While Dolan uses an HM-like presentation (with \emph{bi}unification and \emph{bi}substitution), I illustrate these assumptions in a constraint-based setting. \begin{description}
    \item[Distributive lattice] While constructing a lattice of types for conveniently well-behaved subtyping relations was standard, Dolan found it crucial for the lattice to be \emph{distributive} \cite[Section~3.2]{dolan-thesis}.\footnote{Looking ahead, Figure \ref{fig:boolean-laws} lists the laws of a distributive lattice (labels $\mathsf L$, $\mathsf B$).} While his main motivation is to ensure subsumption is decidable, this is a useful assumption in general.
    \item[Polarity restriction] Dolan \cite[Section~5.1]{dolan-thesis} uses a \emph{polar types} construction due to \textcite{pottier-thesis}, where the type language is split into positive $\tau^+$ and negative $\tau^-$ types -- corresponding to \emph{outputs} (which we lower-bound) and \emph{inputs} (dually: upper-bound). We restrict joins and meets so that $\tau^+ ::= \cdots \mid \tau^+ \join \tau^+$ and $\tau^- ::= \cdots \mid \tau^- \meet \tau^-$,
    and ensure polarities in type constructors agree with their variance.\footnote{Covariance preserves polarity, but contravariance flips it: for functions, $\tau^+ ::= \cdots \mid \tau^- \to \tau^+$ and $\tau^- ::= \cdots \mid \tau^+ \to \tau^-$}
    
    The polarity restriction ensures subtyping constraints have form $\tau^+ \sub \tau^-$ (\cf{} data flows from outputs to inputs \cite[Section~1.1]{dolan-thesis}). Hence, we can \emph{split} meets and joins via lattice laws \cite{simple-sub}: 
    \begin{align*}
        \tau' \join \tau'' \sub \tau \iff \tau' \sub \tau \text{ and } \tau'' \sub \tau \qquad
        \tau \sub \tau' \meet \tau'' \iff \tau \sub \tau' \text{ and } \tau \sub \tau''
    \end{align*}

    I decided to investigate follow-up work that loosens this restriction (\eg{} allowing functions of type $\alpha 
    \to \alpha \meet \flrec{\ell : \beta}$), and \inference{} does not apply the polarity restriction. Initially, I motivated this choice by the intuition it would be necessary for typing extensible records. However, my technique is ultimately compatible with the polarity restriction (see end of Section~\ref{subsec:breaking-records}).
\end{description}

\begin{example}
    In the distributive lattice of FL types (see Appendix \ref{extra:fl-constraints}), we compute:
    \begin{align*}
        (\top \to \bot) \meet (\alpha \to \beta) &= \top \to \bot \\ 
        \flext{\mathrm{quack} : \top, \mathrm{walk} : \flrec{}}{\flabsent} \meet \flext{\mathrm{quack} : \top \to \top}{\flftop} &= \flext{\mathrm{quack}: \top \to \top, \mathrm{walk}: \flrec{}}{\flabsent} \\ 
        \flrec{\mathrm{foo}: \flrec{}} \join (\top \to \top) &= \top
    \end{align*}
\end{example}

\subsubsection{Later work (Parreaux, Chau)}
\label{subsubsec:parreaux}

While Dolan's work is foundational, \inference{} is closer descended from follow-up work: \simplesub{} of \textcite{simple-sub}, and \mlstruct{} of \textcite{mlstruct}. I highlight the following developments: \begin{description}
    \item[Constraint graphs] \textcite{simple-sub} found that Dolan's \emph{biunification} approach can be difficult to implement and extend. He proposed an alternative approach in \simplesub{} that relies on explicitly introducing subtyping constraints and imperatively updating a \emph{constraint graph}. Likewise, I do not use Dolan's biunification (due to the next point), but my method does not rely on mutation.\footnote{While this is arguably a stylistic choice, purity seems to make the implementation easier to reason about.}
    \item[Boolean algebra] In Parreaux's constraint graph setting, \textcite{mlstruct} propose \mlstruct{}, featuring \emph{complement (negation) types} and removal of the polarity restriction. They use \simplesub{}-like constraint solving by requiring complements (with meets \& joins) to form a \emph{Boolean algebra}\footnote{A bounded, distributive and complemented lattice -- see Figure \ref{fig:boolean-laws} as reference.}. My approach to constraint solving directly inherits from theirs. However, I attempt to clarify that negations are added to the type language as a \emph{free extension} of the distributive lattice of type constructors, explaining why they are a safe addition (Section~\ref{subsec:oh-god-complements}).
    \item[Non-extensibility] For Dolan, extensibility also means that \enquote{useless} types like $(\alpha \to \beta) \join \flrec{\ell : \gamma}$ should not be \emph{equal} to $\top$ \cite[Section~1.4.1]{dolan-thesis} -- even though they can only be eliminated as such. \textcite{mlstruct} do not follow this consequence of extensibility (but not others, \eg{} distributivity), arguing that this provides better user experience and eases constraint solving. I also do so, but do not share their scepticism of extensibility \cite{simple-sub}, agreeing with Dolan that it is an important principle. 
\end{description}

\section{Signature}
\label{sec:signature}

We consider the external side of the \inference{} framework -- the \emph{signature}, \ie{} the requirements it entails on the source language. 
All constructs described here are available as \textbf{data} upholding certain \textbf{laws}, key for constraint solving  (Section~\ref{sec:constraints}). I endeavour to generalise the properties necessary for \mlstruct{}'s solver.

\subsection{Type constructors}

Firstly, following standard practice \cite{essence-of-ml-type-inference, constraint-based-freeze-ml}, we will abstract away \emph{type constructors} in the type language. We denote them $\constr[\overline \tau]$, where $\overline \tau$ stands for the list of types that occur within.
\begin{example}
    In FL we have the function and record type constructors. Writing \enquote{$\cdot$} for \emph{type holes} in constructors:
    $$
       \constr ::= \top \mid \bot \mid {\cdot} \to {\cdot} \mid \flext{\ell : \dot \phi}{\dot \phi} \qquad \dot \phi ::= \flftop \mid \flfbot \mid \cdot \mid \flabsent
    $$
    Writing $\constr[\overline \tau]$, we plug in $\overline \tau$ into each \enquote{$\cdot$} in $\constr$ in order. This establishes that type constructors $\constr$ non-opaquely contain subterms $\tau$. Here are example types $\constr[\overline \tau]$:
    $$
        (\cdot \to \cdot)[\top, \bot] = \top \to \bot \qquad \flext{\mathrm{foo}: \cdot, \mathrm{bar} : \flabsent}{\flftop}[\top \to \top] = \flext{\mathrm{foo}: \top \to \top, \mathrm{bar} : \flabsent}{\flftop}
    $$
\end{example}

\needspace{5em}
As expected, we require that type constructors $\constr[\overline \tau]$ form a distributive lattice $(\top, \bot, \cjoin, \cmeet)$, where $\top$ and $\bot$ are nullary type constructors and $\cjoin$ and $\cmeet$ are closed binary operators on type constructors. 

When solving constraints, we wish to break down constraints into bounds on type variables. Hence, we have to decompose \enquote{compound} subtyping constraints -- those on type constructors. We thus require a \textbf{decomposition} operator $\constr[\overline \tau] \cdecomp \constr[\overline \tau] = c$, specific to a given type language. It decomposes a \emph{subtyping constraint} between two type constructors into an equivalent (general) \emph{constraint}:
$$ (\constr'\left[\overline {\tau'}\right] \sub \constr''\left[\overline {\tau''}\right]) \cstreq (\constr\left[\overline {\tau'}\right] \cdecomp \constr'\left[\overline {\tau''}\right]) $$
where the resulting constraints contain structurally smaller type constructors.\footnote{We do not formalise this property, but it would be necessary to do so to prove the constraint solving process terminates.} Decomposition is where type errors arise in the system (\eg{} $\top \cdecomp \bot = \fals$, as $\top \sub \bot$ is always false). 
% Together with the type constructor lattice and constraint decomposition, we can effectively massage constraints involving type constructors. 
\begin{example}
    Constraints on function type constructors decompose as such:
    $$ (\tau \to \pi) \cdecomp (\tau' \to \pi') = \tau' \sub \tau \und \pi \sub \pi' $$
    The type constructor lattice given by $\cmeet$ and $\cjoin$ always agrees with $\meet$ and $\join$ on types (Fig. \ref{fig:boolean-laws}), so:
    \begin{align*}
       (\top \to \top) \meet (\bot \to \bot) 
       &\typeq (\cdot \to \cdot)[\top, \top] \cmeet (\cdot \to \cdot)[\bot, \bot] = (\cdot \to \cdot)[\top \cjoin \bot, \top \cmeet \bot] \\
       &= (\cdot \to \cdot)[\top, \bot] \typeq \top \to \bot 
    \end{align*}
\end{example}

\begin{figure}
    \centering
    \begin{align*}
    \graintro \tau 
             \alpha & \text{(variable)}
    \graitem \constr[\overline \tau] & \text{(constructor)}
    \graitem \tau \join \tau & \text{(join)}
    \graitem \tau \meet \tau & \text{(meet)}
    \graitem \lnot \tau & \text{(complement)} \\[-2em]
    \end{align*}
    \caption{Syntax of types $\tau$ in \inference{}.}
    \label{fig:signature-types}
\end{figure}

\begin{figure}
    \centering
    % $$ \mathbb B = (\tau, \sub, \top, \bot, \join, \meet) $$ 
    $$ \boxed{\tau \typeq \tau} $$
    $$ \renewcommand\arraystretch{1.1} \begin{array}{cr}
    \tau \join (\tau' \join \tau'') \typeq (\tau \join \tau') \join \tau'' \quad 
    & \text{($\mathsf L$: associativity \mbox{$\join$})}
    \\
    \tau \meet (\tau' \meet \tau'') \typeq (\tau \meet \tau') \meet \tau''
    & \text{($\mathsf L$: associativity \mbox{$\meet$})} 
    \\
    \quad
    \tau \meet \tau' \typeq \tau' \meet \tau 
    & \text{($\mathsf L$: commutativity)}
    \\
    \tau \join (\tau \meet \tau') = \tau
    \quad 
    \tau \meet (\tau \join \tau') = \tau
    & \text{($\mathsf L$: absorption)}
    \\ 
    \tau \join \bot \typeq \tau
    \quad 
    \tau \meet \top \typeq \tau 
    & \text{($\mathsf B$: bounds)} 
    \\
    \tau \meet (\tau' \join \tau'') \typeq (\tau \meet \tau') \join (\tau \meet \tau'')
    & \text{($\mathsf D$: distributivity)}
    \\
    \tau \join \comp \tau = \top 
    \quad
    \tau \meet \comp \tau = \bot
    & \text{($\mathsf C$ complements)} 
    \\ 
    \constr_1\left[\overline {\tau'}\right] \join \constr_2\left[\overline {\tau''}\right] \typeq \constr_1\left[\overline {\tau'}\right] \cjoin \constr_2\left[\overline {\tau''}\right]
    & \text{(type constructor $\cjoin$/$\join$)}
    \\
    \constr_1\left[\overline {\tau'}\right] \meet \constr_2\left[\overline {\tau''}\right] \typeq \constr_1\left[\overline {\tau'}\right] \cmeet \constr_2\left[\overline {\tau''}\right]
    & \text{(type constructor $\cmeet$/$\meet$)}
    \\[0.5em] 
    \dfrac{\tau \typeq \tau'}{E[\tau] \typeq E[\tau']} 
    & \text{(congruence)}
    \end{array} $$
    $$ \equivctx ::= \ctxhole \mid \constr[\overline \tau, \ctxhole, \overline \tau] \mid \equivctx \join \tau \mid \tau \join \equivctx \mid \equivctx \meet \tau \mid \tau \meet \equivctx \mid \comp \equivctx $$
    \caption{Laws of the Boolean algebra of types and the lattice of type constructors, forming the equivalence $\tau \typeq \tau$. Equivalence contexts $\equivctx$ are used to specify the congruence rule. We have laws of a lattice (labelled $\mathsf L$) that is bounded ($\mathsf B$), distributive ($\mathsf D$), and complemented ($\mathsf C$) -- altogether, a Boolean algebra.}
    \label{fig:boolean-laws}
\end{figure}

\subsection{Type language}

We now describe the syntax of types (Figure \ref{fig:signature-types}). Loosely following \textcite{mlstruct}, we define it so that types form a free Boolean algebra over type constructors and variables\footnote{Like \textcite{dolan-thesis}, our type variables are \emph{opaque} in the lattice -- avoiding a closed-world assumption about their possible values.}. This algebra satisfies Boolean algebra laws and the laws of the type constructor lattice (Figure~\ref{fig:boolean-laws}) under type equivalence $\tau \equiv \tau$.\footnote{Following this, the algebra of types is free extension of the algebra of type constructors with variables and complements.} Subtyping $\sub$ must agree with the type algebra and the typing judgement:
$$ \begin{array}{c}
   \tau \sub \pi \iff \tau \typeq \tau \meet \pi \iff \pi \typeq \tau \join \pi \\[5pt]
   \dfrac{\Gamma \vdash e : \tau \quad \tau \sub \tau'}{\Gamma \vdash e : \tau'}
\end{array} $$

\subsection{Complement types} 
\label{subsec:oh-god-complements}
Following \textcite{mlstruct}, our complement types have algebraic foundation, as opposed to a set-theoretic one. The two have different interpretations of subtyping, denoted $\comp$ and $\dot \comp$:\footnote{The algebraic interpretation follows by: $\pi \sub \comp \tau \implies \pi \meet \tau \sub \tau \meet \comp \tau \implies \pi \meet \tau \sub \bot$, and $\pi \meet \tau \sub \bot \implies (\pi \meet \tau) \join \comp \tau \sub \comp \tau \implies (\pi \join \comp \tau) \meet (\pi \join \comp \tau) \sub \comp \tau \implies (\pi \join \comp \tau) \meet \top \sub \comp \tau \implies \pi \join \comp \tau \sub \comp \tau \implies \pi \sub \comp \tau$.}
\begin{align*}
    \pi \sub \dot \comp \tau \;&\iff \pi \not\sub \tau & \text{(set-theoretic)} \\
    \pi \sub \comp \tau \;&\iff \pi \meet \tau \sub \bot & \text{(algebraic)} 
\end{align*}
Set-theoretic-like complements notoriously make constraint solving harder, smuggling negations into the underlying logic. On the other hand, our algebraic complement types provide a weaker condition, but one of great help to constraint solving -- as we explore in Section \ref{sec:constraints}.

\begin{example}
    Take $\pi = \flext{\mathrm{foo}: \flabsent }{\flftop}$ and $\tau = \flext{\mathrm{foo}: \top}{\flftop}$. The two interpretations of $\pi \sub \comp \tau$ disagree: \begin{description}
        \item[Set-theoretic] It is not the case that $\pi \sub \tau$, thus $\pi \sub \dot \comp \tau$. $\checkmark$
        \item[Algebraic] Based on Figure \ref{fig:featherweight-lua-subtyping}, we have $\pi \meet \tau = \flext{\mathrm{foo} : \flfbot }{\flftop} \not\sub \bot$, so $\pi \not\sub \comp \tau$. $\lightning$
        \end{description}
    Note that $\comp$ admits fewer subtypes than $\dot \comp$, since for any sets $A$ and $B$: 
    $$A \cap B = \varnothing \implies \lnot(A \subseteq B) \qquad\text{thus}\qquad \tau \sub \comp \pi \implies \tau \sub \dot\comp \pi $$ 
    % Intuitively, algebraically we require an empty (bottom) intersection between the types, not non-subset.
\end{example}

\subsection{Summary} Summarising the requirements of \inference{}'s signature: \begin{itemize}
    \item Type constructors form a distributive lattice, and subtyping constraints on them 
    can be decomposed.
    \item The type language forms a Boolean algebra.
    \item The type system admits an implicit subtyping rule.
\end{itemize} 
To determine these, I was inspired by the requirements of techniques of \textcite{mlsub} and \textcite{mlstruct}.
Later, we see that \fabric{} (Chapter \ref{fabric}) and \starr{} (Chapter \ref{star}) both successfully implement the signature of \inference{}, showing it is reasonable in practice.

\section{Constraint solving}
\label{sec:constraints}

We now describe the \mlstruct{}-inspired constraint solving process used in \inference{} using the already described setting of the constraint language and signature. 

I largely follow the tradition of the framework by \textcite{pottier-framework} and the Boolean algebraic techniques of \textcite{mlstruct} in \mlstruct{}. The key difference to \mlstruct{} is a simpler and more extensible presentation, using term rewriting of constraints. Furthermore, in Section \ref{sec:morphisms} I give the main contribution of the framework: extension of the type language and constraint solving with support for \emph{homomorphisms}.

This section is structured as follows: \begin{description}
    \item[\ref{subsec:rewriting} Massaging] We first show that all subtyping constraints $\sub$ can be reduced to a conjunction of \emph{variable-bound} constraints (of syntax $\tau \sub \alpha \,\mid\, \alpha \sub \tau$, mirroring bounded parametric type schemes).
    \item[\ref{subsec:normalisation} Plumbing] Then, we show how we manipulate and combine these variable-bound constraints into a list-of-bounds normal form. We then perform the \emph{closure} computation.
    \item[\ref{subsec:simplification} Solutions] Lastly, we briefly consider how we can extract a type scheme from a normalised generated constraint, and how these can be simplified.
\end{description} 
Altogether, I aim to reproduce\footnote{Due to the complexity of their description, a proof of equivalence seems difficult. However, the core ideas remain the same.} the constraint solving of \textcite{mlstruct} in \mlstruct{} in a constraint-based style that is simpler and easier to extend. 

Constraint solving is given in terms of a small-step term rewriting relation $\step$ (Figure \ref{fig:solver}). The solving process is given by its reflexive-transitive closure, $\step^*$.
To show constraint solving always yields correct results, we rely on a theorem that $\step^*$ preserves constraint satisfaction:
\begin{theorem}[Semantic preservation]
    If $c \step^* c'$, then $c \cstreq c'$.
\end{theorem}
This theorem follows straightforwardly by proving individual cases of $\step$, relying on known Boolean algebra properties \cite{mlstruct}.

We now consider various properties of the constraint-solving steps, giving constructive proofs -- these directly lead to a practical implementation.

\begin{figure}[p]
    \centering
    \begingroup
    \input{Sources/3-Figures/Solver}
    \endgroup
    \caption{Definition of constraint solving steps $\step$. Congruence for $\step$ is given by constraint solving contexts~$\solvectx$.}
    \label{fig:solver}
\end{figure}

\newcommand{\typcnf}{\tau_\text{cnf}}
\newcommand{\typcnfcls}{\tau_\text{cnf-clause}}
\newcommand{\typclsvars}{\tau_\text{cnf-clause-lits}}
\newcommand{\typvar}{\tau_\text{lit}}
\newcommand{\vbnd}{V}
\newcommand{\vbnds}{\vbnd_{\undsym}}

\begin{figure}
    \centering
    \begin{align*}
    \graintro{\typcnf} \top \mid \typcnfcls \meet \typcnf \\
    \graintro{\typcnfcls} \constr \left[ \overline{\typcnf} \right] \join { \comp \constr \left[ \overline{\typcnf} \right]} \join \typclsvars \\
    \graintro{\typclsvars} \bot \mid \typvar \join \typclsvars \\
    \graintro{\typvar} \alpha \mid \comp \alpha
    \end{align*}
    \caption{Grammar of the conjunctive normal forms (CNF) for types $\tau$ -- a \emph{meet-of-clauses} $\typcnf$, where clauses $\typcnfcls$ are \emph{joins-of-atoms}. Clauses have only one type constructor $\constr$ at each polarity, but many variables. We additionally require that no $\typvar$ occurs twice in $\typclsvars$.}
    \label{fig:type-cnf}
\end{figure}

\subsection{Massaging}
\label{subsec:rewriting}
We define the syntax of a \emph{variable bound} $\vbnd$ and \emph{variable bounds} $\vbnds$ constraints as:
$$
    \vbnd ::= \tau \sub \alpha \mid \alpha \sub \tau \qquad
    {\vbnds} ::= \tru \mid V \mid \vbnds \und \vbnds
$$
We shall show by construction that:
\begin{theorem}[Subtyping constraints yield variable bounds]
    Given $c = (\tau \sub \pi)$, we have that:
    $$ c \step^* \fals \;\text{ or }\; \exists c' = \vbnds \ldotp c \step^* c' $$
\end{theorem}
Let us call type constructors and type variables \emph{atoms} (literals).
The proof sketch is as follows:
\begin{enumerate}
    \item Show all subtyping constraints are equivalent to $\top \sub \typcnf$,\footnote{Notice that $\top \sub \tau \iff \top = \tau$.} 
    for a type $\typcnf$ in \emph{conjunctive normal form} (or a \emph{meet-of-joins-of-atoms}) -- as defined in Figure \ref{fig:type-cnf}.
    \item Split the constraint into a conjunction of constraints $\top \sub \typcnfcls$ (CNF clause; \emph{join-of-atoms}).
    \item Use \emph{swapping} to give variable bounds for each occurring variable, yielding $\vbnds$.
\end{enumerate}
The technique is essentially the same as \textcite{mlstruct}, but my presentation is generalised (up to the signature) and more direct (constraint-based). Like them, I call this process \emph{constraint massaging}. 
% We now give a sketch of the main aspects of the construction.

\begin{proof}
We write $\mathrm{cnf}(\tau)$ for the $\typcnf$ such that $\tau \equiv \typcnf$. CNF can be built compositionally, analogously to usual Boolean algebra techniques.\footnote{There is an analogous \emph{disjunctive normal form} (DNF) in my implementation -- while not necessary, it can be more size-efficient.} To transform any $c = \tau \sub \pi$ into $\top \sub \typcnf$ we step like so:
$$ \tau \sub \pi \stackrel{\text{swap}}{\step} \top \sub \comp \tau \meet \pi \stackrel{\text{equiv.}}{\step} \top \sub \mathrm{cnf}(\comp \tau \meet \pi) $$
at which point we reach a $c' = \top \sub \typcnf$ equivalent to $c$. By simple induction we can see that we can split this into a conjunction of constraints $\top \sub \typcnfcls$, since:
$$ \top \sub \typcnfcls \meet \typcnf \;\stackrel{\text{split}}{\step}\; \top \sub \typcnfcls \und \top \sub \typcnf $$
It remains to show $\top \sub \typcnfcls \step^* \vbnds$. Let $\typcnf = \constr' \left[ \overline{\typcnf'} \right] \join { \comp \constr'' \left[ \overline{\typcnf''} \right]} \join \typclsvars$. By cases: 
\begin{itemize}
    \item If $\typclsvars = \bot$, then:
    $$ \top \sub \constr' \left[ \overline{\tau'_\text{cnf}} \right] \join \comp \constr'' \left[ \overline{\tau''_\text{cnf}} \right] \join \bot \stackrel{\text{equiv.}}{\step} \cdots \stackrel{\text{swap}}{\step} \cdots \stackrel{\text{decomp.}}{\step} \constr'' \left[ \overline{\tau''_\text{cnf}} \right] \cdecomp \constr' \left[ \overline{\tau'_\text{cnf}} \right] $$
    and we proceed recursively at the result of $\cdecomp$, assuming it is well-behaved so we eventually terminate. This is the case where we might reach a \enquote{type-error} constraint $\fals$ (when $\cdecomp$ yields $\fals$).
    \item If $\typclsvars = \typvar \join \typclsvars'$, the constraint is satisfiable ($\typvar \mapsto \top$). We return a conjunction of \textbf{separate}\footnote{We can \emph{sufficiently} take one $\typvar$ -- but no choice is \emph{natural}, so for a principal type scheme we include all of~them.} constraints for each $\typvar$. There are two cases: \\ { \centering
    \begin{tabular}{cc}
        --- If $\typvar = \alpha$, then $\top \sub \alpha \join \tau \stackrel{\text{swap}}{\step} \comp \tau \sub \alpha$. & 
        --- If $\typvar = \comp \alpha$, then $\top \sub \comp \alpha \join \tau' \stackrel{\text{swap}}{\step} \alpha \sub \tau'$.
    \end{tabular} 
    }
\end{itemize}
\end{proof}

\begin{example}
Let us massage
$c = (\alpha \meet \flrec{} \to \beta) \sub (\flrec{\mathrm{foo}: \gamma} \to \top)$. We first decompose:
$$ c \step (\alpha \meet \flrec{} \to \beta) \cdecomp (\flrec{\mathrm{foo}: \gamma} \to \top) = \flrec{\mathrm{foo}: \gamma \sub \alpha \meet \flrec{}}_{c'} \und \beta \sub \top $$
We consider the first conjunct, $c'$ -- the latter is normalised -- and transform into $\top \sub \typcnf$:
$$ c' \step^* c'_\text{cnf} = \top \sub \underbrace{\left( \alpha \join \comp \flrec{\mathrm{foo}: \gamma} \right)}_\text{(1)} \meet \underbrace{\left( \flrec{} \join \comp \flrec{\mathrm{foo}: \gamma} \right)}_\text{(2)} $$
Splitting into clauses (1) and (2), we obtain:
$$ \begin{cases} 
    \top \sub \alpha \join \comp \flrec{\mathrm{foo}: \gamma} \step \flrec{\mathrm{foo}: \gamma} \sub \alpha
    \\
    \top \sub \flrec{} \join \comp \flrec{\mathrm{foo}: \gamma} \step \flrec{\mathrm{foo}: \gamma} \sub \flrec{} \step \flrec{\mathrm{foo}: \gamma} \cdecomp \flrec{} = \tru
\end{cases}$$
$$ \implies c \step^* (\flrec{\mathrm{foo}: \gamma} \sub \alpha \und \tru) \und \beta \sub \top $$
Note that negations appear in intermediate constraints, but not in the output.
\end{example}

\subsection{Plumbing}
    \label{subsec:normalisation}
    
\newcommand{\sbnd}{W}

We now consider the normalisation of variable bounds and the transitive closure computation in the style of \textcite{pottier-framework}. These techniques were first described for algebraic subtyping by \textcite{simple-sub} for \simplesub{} (and thus inherited by \mlstruct{}) -- I adapt them to the constraint-based presentation.

\emph{Normalised bounds} $\sbnd$ have syntax:
$$ \sbnd ::= \tru \mid (\tau \sub \alpha \und \alpha \sub \tau) \und \sbnd $$
constrained such that no $\alpha$ occurs twice, and $\alpha$s are sorted under some fixed total ordering. We have only shown that subtyping constraints reduce to (multiset-like) variable bounds $V^*$, but we can strengthen this:
\begin{lemma}[Normalisation of bounds]
For any $c = \vbnds$, there exists $c' = \sbnd$ such that $c \step^* c'$.
\end{lemma}
\begin{proof}
    Straightforward by $\undsym$ forming a commutative monoid and by the \emph{combining} step.
\end{proof}
To move towards general constraints, we also have a lemma that existentials can be lifted to the top-level:
\begin{lemma}[Top-level existentials]
    For any $c$, there exists $c'$ such that $c'$ has no existentials and $c \step^* \exists \overline \alpha \ldotp  c'$.
\end{lemma}
\begin{proof}
    (This is simplified by the constraint language only featuring conjunctions and existentials besides the subtyping predicate). Straightforward using the fact $\exists$ can always be \emph{factored out} from conjunctions.
\end{proof}
Finally, I give the normal form of constraints $\hat c$ -- normalised bounds with top-level existentials:
$$ \hat c ::= \mathbf F \mid \exists \overline{\alpha} \ldotp \sbnd $$

We can now state that \textbf{constraints normalise}:
\begin{theorem}[Normalisation of constraints]
For any $c$, there exists $\hat c$ such that $c \step^* \hat c$.
\end{theorem}
\begin{proof}
    By factoring out existentials to the top-level, and normalising the variable bounds.
\end{proof}
Lastly, whenever we are in a list-of-bounds form, we can invoke transitivity. This yields an additional constraint $\tau^+_\alpha \sub \tau^-_\alpha$ for each $\tau^+_\alpha \sub \alpha \und \alpha \sub \tau^-_\alpha$ in the list. Invoking transitivity and normalising can only yield stronger bounds, \ie{} the process is monotone under the order $\preceq$ defined as:\footnote{Introducing another subsumption-like relation might be surprising, but $\preceq$ is more useful here as it is syntactic (checks bounds) rather than semantic (as $\subsume$, which checks instantiations). It is also a stronger condition: $\preceq$ implies $\subsume$.}
$$ \hat c' \preceq \hat c \iff \hat c' = \fals \text{ or } (\forall \alpha \ldotp \pi_\alpha^+ \sub \tau_\alpha^+ \text{ and } \tau_\alpha^- \sub \pi_\alpha^-) $$
where $\tau_\alpha$ and $\pi_\alpha$ are the bounds on a variable $\alpha$ in $\hat c'$ and $\hat c$, respectively.
While it is expected this process terminates \cite{pottier-framework, simple-sub, mlstruct} -- determining satisfiability -- I only conjecture it and give empirical evidence of termination:
\begin{conjecture}
    For any normalised constraint $\hat c$, applying transitivity at each $\alpha$ and leads to some $\hat c'$ such that $\hat c' \preceq \hat c$. This process eventually reaches a fixed-point -- the \textbf{solved constraint} $\mathcal S(c)$.
\end{conjecture}

\begin{example}
    Denoting applications of transitivity by $\Rightarrow$, first consider:
    \begin{align*}
        & \flext{\mathrm{quack}: \beta}{\flabsent} \sub \alpha \und \alpha \sub \flext{\mathrm{quack}: \top \to \top }{\flftop} \\
        \Rightarrow\;& \flext{\mathrm{quack}: \beta}{\flabsent} \cdecomp \flext{\mathrm{quack}: \top \to \top }{\flftop} = \gamma \sub \top \to \top
    \end{align*}
    where we obtained a bound on the type $\beta$ of the field $\mathrm{quack}$. Now consider:
    $$ (\top \to \top \sub \gamma) \und (\gamma \sub \flrec{}) \;\implies\; ((\top \to \top) \cdecomp \flrec{}) = \fals $$
    where we reached a contradiction on satisfying bounds on $\gamma$.
\end{example}

\subsection{Solutions}
\label{subsec:simplification}

We now briefly consider the question of extracting the type scheme from a solved constraint. 

Given a generated constraint $\cstr{\cdot}{e}{\tau}$, if it is solved successfully we have some $\mathcal S \left( \cstr{\cdot}{e}{\tau} \right) = \exists \overline{\alpha} \ldotp \sbnd$, and return the type scheme $\sch =  \forall W \ldotp \tau$.

It is important to simplify type schemes -- however, I do not propose novel ways to do this, and entirely refer to \textcite{simple-sub} and \textcite{mlstruct}. In practice, I have found that to ensure efficient termination I had to simplify the CNF forms with standard techniques. Inlining bounds (like \textcite{dolan-thesis}) and removing redundant type variables mainly serves to improve readability.

\begin{example}
    Given
    $e = \fllam x \fllam y \flproj{(x \, \{ \mathrm{quack} = y \})}{\mathrm{sound}}$,
    my implementation produces $\cdot \vdash e : \sch$ and a simplified $\sch' \equiv^\forall \sch$ (\ie{} $\sch' \subsume \sch \subsume \sch'$) as such:
    \begin{align*}
    \mathcal S(\cstr{\cdot}{e}{\alpha}) \cong \exists \beta, \gamma, \delta, \varepsilon \ldotp \alpha \sub \beta \to \gamma \to \delta \und& \beta \sub \flext{\mathrm{quack}: \gamma}{\flabsent} \to \delta \\ \und& \varepsilon \sub \flext{\mathrm{sound}: \delta}{\flftop} \\
    \sch = \forall \alpha \sub \beta \to \gamma \to \delta,\; \beta \sub \flext{\mathrm{quack}: \gamma}{\flabsent} \to \delta,\;& \varepsilon \sub \flext{\mathrm{sound}: \varepsilon}{\flftop} \ldotp \alpha
    \end{align*}    
    $$ \sch' = \forall \gamma, \delta \ldotp (\flext{\mathrm{quack}: \gamma}{\flabsent} \to \flext{\mathrm{sound} : \delta}{\flftop}) \to \gamma \to \delta $$
\end{example}

\section{Breaking records: Homomorphism extension}
\label{sec:morphisms}

Early on, \textcite{operations-on-records} identified a crucial issue with typing extensible records using subtyping. We exemplify it on an FL program using record extension:
$$ e = \fllam x \fllam y \flext{\ell = y}{x} $$
which would naively be given the (non-principal) type scheme
$$ \cdot \vdash e : \forall \alpha \ldotp \flext{\ell : \flabsent}{\flftop} \to \alpha \to \flext{\ell : \alpha}{\flftop} $$
causing \emph{loss of information} about the non-$\ell$ fields of $x$. We cannot obviously address this with just subtyping and parametric polymorphism \cite{cardelli-extensible-records-in-f-sub}, and the standard solution is extending the system with row polymorphism~\cite{remy-records, abstracting-extensible-data-types}. Such an extension of algebraic subtyping was sketched by \citeauthor*{algebraic-subtyping-row-polymorphism} \cite{algebraic-subtyping-row-polymorphism}.

We might prefer to avoid adding rows to the system -- avoiding the inherent complexity -- and to stick to just bounded parametric polymorphism. One approach to do so is updating a record type underlying a type variable via a \enquote{type-function} $\mathrm{update}_\ell(\tau, \phi) = \tau$, like:
$$ \qquad \cdot \vdash e : \forall \alpha, \rho \sub \flext{\ell : \flabsent}{\flftop} \ldotp \rho \to \alpha \to \mathrm{update}_\ell(\rho, \alpha) \qquad \text{(only a sketch!)} $$
It would be convenient to use \emph{metafunctions on types} to specify type schemes.

I propose to follow the algebraic approach and exploit homomorphisms in the type algebra -- well-behaved (meta)functions -- for this purpose. Thanks to homomorphism laws (and some extra structure), we are able to successfully solve constraints containing applications of homomorphisms to types.
\begin{example}
    For typing extensible records, we use a homomorphism $\mathrm{forget}_\ell$ that sets the type of a field $\ell$ to~$\flftop$.
    Intersecting its result with a singleton $\flrec{\ell : \phi}$ lets us set any field type (as $\forall \phi \ldotp \flftop \meet \phi = \phi$), \eg{}:
    \setlength{\tabcolsep}{0pt}
    $$\begin{array}{rll}
        &\hspace{-0.9em}\tau &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \flabsent}{\flabsent} \\
        \mathrm{forget}_\mathrm{foo}( &\hspace{-0.9em}\tau ) &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \flftop}{\flabsent} \\
        \mathrm{forget}_\mathrm{foo}( &\hspace{-0.9em}\tau ) \meet \flext{\mathrm{foo}: \alpha}{\flftop} &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \alpha}{\flabsent}
    \end{array}$$
    replacing an absent field in $\tau$ with a present $\alpha$. Note $\mathrm{update}_\ell(\tau, \phi) = \mathrm{forget}_\ell(\tau) \meet \flext{ \ell : \phi }{\flftop}$.

    $\mathrm{forget}_\ell$ is essentially the retraction operator on record types of \textcite{operations-on-records}.
\end{example}

\begin{figure}
    \centering
    $$\boxed{\tau \typeq \tau}$$
    \vspace{-2.5em}
    \begin{align*}
        \quad\quad\morph(\tau \meet \pi) &\typeq \morph(\tau) \meet \morph(\pi) \\
        \morph(\tau \join \pi) &\typeq \morph(\tau) \join \morph(\pi) \\
        \morph(\top) &\typeq \top \\
        \morph(\bot) &\typeq \bot
    \end{align*}
    \vspace{-1.5em}
    $$ \equivctx ::= \cdots \mid \morph(\equivctx) $$
    \caption{Homomorphism laws in the Boolean algebra of types, which extend the definition of equivalence $\tau \typeq \tau$. Note that $\morph(\comp \tau) \typeq \comp \morph(\tau)$ follows from these laws (by a routine check of complement axioms).}
    \label{fig:morphism-laws}
\end{figure}

\textcite{oxcaml} use a similar approach, introducing a \emph{dagger} function $\dagger$ in a simple polar \emph{mode language}. In contrast, my approach works with variables and without polarities.

\subsection{Signature}
\label{subsec:signature-morphisms}

Firstly, we add applications of \textbf{homomorphisms} $\morph$ -- specific to a given language -- to the syntax of types:
$$ \tau ::= \cdots \mid \morph(\tau) $$
We extend type equivalence to respect the homomorphism laws (Figure \ref{fig:morphism-laws}). We also must have a homomorphism $\mathrm{id}$ such that $\mathrm{id}(\tau) \typeq \tau$ for all $\tau$, and require homomorphisms \emph{compose} with a $\circ$ such that: $$\left( \morph' \circ \morph'' \right)(\tau) \equiv \morph'\left( \morph''(\tau) \right)$$

\subsubsection{Adjoints}

\paragraph{Motivation}
While most of the constraint solving process can be easily adapted to homomorphisms, it is problematic to transform constraints $\morph(\alpha) \sub \tau$ (or $\tau \sub \morph(\alpha)$) into bounds on $\alpha$. 
To solve this, I was inspired by a folklore constraint solving trick: for any $f : X \to Y$ we find a $g : Y \to X$ such that $f(x) \sub y \iff x \sub g(y)$ -- a \textbf{Galois connection}, \ie{} an adjoint pair $f \dashv g$ in the preorder $\sub$. Indeed, at $\morph \mapsto f$, $x \mapsto \alpha$, $y \mapsto \tau$, $g \mapsto \radj \morph$ we get a variable bound for $\alpha$ via $\morph(\alpha) \sub \tau \iff \alpha \sub \radj \morph(\tau)$.

Some useful morphisms (like $\mathrm{forget}$ and $\mathrm{free}$) do not fit in this Galois connection framework. I thus extended it with \emph{remainder} constraints.

\paragraph{Development}
To facilitate solving of general constraints,\footnote{In special cases (\eg{} under a polarity restriction of homomorphisms), we might only need a left- or right- adjoint.} we require homomorphisms $\morph$ have an \emph{adjoint-like} structure given by \emph{left-} and \emph{right-adjoint} homomorphisms $\ladj \morph$ and $\radj \morph$ for all $\morph$. We also allow \emph{remainder} constraint functions $\ladjrest \morph(\tau) = c$ and $\radjrest \morph(\tau) = c$, so that we have equivalences:
\begin{align*}
(\morph(\tau) \sub \pi) &\cstreq \left(\tau \sub \radj \morph(\pi) \und \radjrest \morph(\pi) \right) \\
(\tau \sub \morph(\pi)) &\cstreq \left(\ladj \morph(\tau) \sub \pi \und \ladjrest \morph(\tau) \right)
\end{align*}
The use of $\ladjrest \morph$ and $\radjrest \morph$ makes it clear why we call these remainders: when they introduce no further constraint ($\ladjrest \morph = \radjrest \morph = \tru$), $\ladjrest \morph$ and $\radjrest \morph$ are precisely left and right Galois connections to $\morph$.

\begin{example}
    In order to give $\mathrm{forget}_\ell$  adjoint-like structure, it needs a \enquote{dual}. We call this dual $\mathrm{free}_\ell$, and define it to set field $\ell$ to $\flfbot$. We have the following adjoints and remainders (per Appendix \ref{extra:fl-constraints}):
    $$\begin{array}{c|cccc}
    \morph & \ladj \morph & \ladjrest \morph(\tau) & \radj \morph & \radjrest \morph(\tau) \\ \hline 
    \mathrm{forget}_\ell & \mathrm{free}_\ell & \tru & \mathrm{id} & \flext{\ell : \flftop}{\flfbot} \sub \tau \\
    \mathrm{free}_\ell & \mathrm{id} & \tau \sub \flext{\ell : \flfbot}{\flftop} & \mathrm{forget}_\ell & \tru \\ 
    \mathrm{id} & \mathrm{id} & \tru & \mathrm{id} & \tru 
    \end{array}$$    
    $\mathrm{free}_\ell$ and $\mathrm{forget}_\ell$ form an \enquote{adjoint pair} (inspiring the naming, \cf{} free-forgetful adjunction).
\end{example}

\subsection{Constraint solving}

We now extend the constraint solving process of Section \ref{sec:constraints} to support homomorphisms. This is relatively straightforward: we only need to amend the construction of variable bounds from subtyping constraints. Thus, we firstly amend the syntax of literals $\typvar$ (in $\typcnf$):
$$ \typvar ::= \morph(\alpha) \mid \comp  \morph(\alpha) $$
which generalises $\typvar$ (at $\morph = \mathrm{id}$).
Crucially, we can still construct the CNF thanks to the fact that $\morph$ are homomorphisms: we just \emph{push down} all applications (\ie{} $\morph(\typcnf)$ applies $\morph$ to all $\typvar$ within $\typcnf$).

For constructing variable bounds, only the final cases are affected -- we need to show $\top \sub \typvar \join \tau$ gives a variable bound. We sketch how to do this by exploiting the adjoint-like structure (via appropriate $\step$ rules):
\begin{itemize}
    \item If $\typvar = \morph(\alpha)$, then $\top \sub \morph(\alpha) \join \tau \stackrel{\text{swap}}{\step} \comp \tau \sub \morph(\alpha) \stackrel{\text{left-adj}}{\step} \ladj \morph(\tau) \sub \alpha \und \ladjrest \morph(\tau) $.
    \item If $\typvar = \morph(\comp \alpha)$, then $\top \sub \comp \morph(\alpha) \join \tau \stackrel{\text{swap}}{\step} \morph(\alpha) \sub \tau \stackrel{\text{right-adj}}{\step} \alpha \sub \radj \morph(\tau) \und \radjrest \morph(\tau)$.
\end{itemize}
where we proceed recursively on any remainder constraints. 
Note that constraints $\top \sub \typvar \join \tau$ remain always satisfiable, since we can always set $\typvar$ to $\top$ (since $\morph(\bot) \equiv \bot$, $\morph(\top) \equiv \top$).

\subsection{Typing extensible records}
\label{subsec:breaking-records}
Having described the use of type homomorphisms in constraint solving, we present the promised concrete application -- typing extensible records, presented for Featherweight Lua. To this end, we define the homomorphisms $\mathrm{forget}_\ell$ and $\mathrm{free}_\ell$ (introduced in examples):
$$ 
\dfrac
  {\tau = \flext{\ell' : \phi_{\ell'},  \overline{\ell : \phi_\ell}}{\phi}}
  {\mathrm{forget}_\ell(\tau) = \flext{\ell' : \flftop,  \overline{\ell : \phi_\ell}}{\phi}}
\qquad 
\dfrac
  {\tau = \flext{\ell' : \phi_{\ell'},  \overline{\ell : \phi_\ell}}{\phi}}
  {\mathrm{free}_\ell(\tau) = \flext{\ell' : \flfbot,  \overline{\ell : \phi_\ell}}{\phi}}
$$
We can now give a rule \textsc{FL-Typ-HExt}, equivalent to the \emph{rule scheme} \textsc{FL-Typ-Ext} -- which we cannot generate constraints for, while avoiding the update problem \cite{operations-on-records}. The two are given below:
$$
\irule{FL-Typ-Ext}
    {\Gamma \vdash e : \flext{\ell' : \flabsent, \overline{\ell : \phi_\ell}}{\phi} \quad \Gamma \vdash e' : \tau'}
    {\Gamma \vdash \flext{\ell' = e'}{e} : \flext{\ell' : \tau', \overline{\ell : \phi_\ell}}{\phi}}
\quad 
\irule{FL-Typ-HExt}{\Gamma \vdash e : \tau \meet \flext{\ell' : \flabsent}{\flftop} \quad \Gamma \vdash e' : \tau'}{\Gamma \vdash \flext{\ell' = e'}{e} : \mathrm{forget}_{\ell'}(\tau) \meet \flext{\ell' : \tau'}{\flftop}}
$$
We can straightforwardly generate constraints for 
\textsc{FL-Typ-HExt}.
% (sketch of the proofs of homomorphisms laws and equivalence of \textsc{FL-Typ-Ext} and \textsc{FL-Typ-HExt})
Thus, the development solves the record update problem under algebraic subtyping without row polymorphism. For details, see Appendix \ref{extra:fl-constraints}.

\paragraph{Polarity restriction} Lastly, I note that:
$$ \mathrm{update}_\ell(\tau, \phi) = \mathrm{free}_\ell(\tau) \join \flext{ \ell : \phi }{\flfbot} = \mathrm{forget}_\ell(\tau) \meet \flext{ \ell : \phi }{\flftop}  $$ 
Hence, the approach is compatible with the polarity restriction: we can use the meet or join version of $\mathrm{update}$ depending on the target polarity. Likewise, adjoints agree with polarities.

In fact, \inference{} has a polarity-restricted subset, in which all constraints are of form $\tau^+ \sub \tau^-$, and thus intermediate $\typcnf$ have single-literal clauses. There, we require homomorphisms preserve polarity.

\needspace{6em}
\section{Correctness}
\label{sec:correctness}

I state correctness theorems for \inference{}, particularly for \emph{solved constraints} $\mathcal S(c)$. We begin with soundness:
\begin{theorem}[Soundness]
    For all $\psi$ and $c$, $\psi \vdash \mathcal S(c)$ if and only if $\psi \vdash c$.
\end{theorem}
\begin{proof}
    Follows directly by semantic preservation of $c$, since $c \leadsto^* \mathcal S(c)$ by construction.
\end{proof}

However, I do not provide proofs for the following theorems -- and only provide evidence based on my implementation (Chapter \ref{fabric}). I note that \inference{} generalises prior work where these properties hold \cite{simple-sub, mlstruct}. 

\begin{conjecture}[Termination]
    Constraint solving $\mathcal S(c)$ described in Section \ref{sec:constraints} always terminates.
\end{conjecture}

\begin{conjecture}[Completeness]    
    For all $c$, $\mathcal S(c) \ne \fals$ if and only if $\exists \psi \ldotp \psi \vdash c$.
\end{conjecture}

\begin{conjecture}[Principality]
    Returned type schemes are minimal under both $\subsume$ and $\preceq$.
\end{conjecture}

Note that: \begin{itemize}
    \item Termination requires appropriate choices of $\cdecomp$, $\ladjrest \morph$/$\radjrest \morph$, and ensuring the fixed-point is found after a finite number of iterations.
    \item Completeness relies on the transitive closure finding all possible contradictions in the system -- which is a standard result in constraint-based type inference, particularly the work of \textcite{pottier-framework} (Pottier attributes the \emph{closure} computation to \textcite{closure-in-type-inference}).
    \item Principality for $\preceq$ seems straightforward (by construction of the closure), and leads to principality for $\subsume$, as $\preceq$ is a stronger condition.
\end{itemize}
We do not consider decidability of subsumption of type schemes (to the well-founded dismay of \textcite{dolan-thesis}). I instead rely on the claim of \textcite{mlstruct} that it is resolvable by solving an appropriate constraint, and thus subsumption is decidable given the constraint solving process terminates.

\section{Conclusions}
\label{sec:conclusions}

I have described \inference{} -- a language-agnostic, constraint-based type inference framework based on algebraic subtyping, as introduced by \textcite{mlsub}.
It soundly infers bounded parametric type schemes in the presence of structural subtyping. 

I use elegant Boolean algebraic techniques, as set out by \textcite{mlstruct}. I extend their work with \emph{type homomorphisms}, uncovering a new direction in the design of type systems using algebraic subtyping. They are used to infer types for not only FL (Chapter \ref{static-soul}; thus \fabric{} in Chapter \ref{fabric}), but later also \starr{} (Chapter \ref{star}; with a $\iota$ \emph{shape-index isomorphism}).

Thanks to its general specification in terms of a necessary signature of the source language, \inference{} improves the understanding of what languages can have their types inferred using algebraic subtyping.

My description lends itself directly to an implementation, which is part of my deliverable -- the \compiler{} compiler for the \fabric{} language -- and described in the following Chapter \ref{fabric}.
