\newcommand{\mlsub}{\textsc{MLsub}}
\newcommand{\simplesub}{\textsc{Simple-sub}}
\newcommand{\mlstruct}{\textsc{MLstruct}}
\newenvironment{example}{ %
    \begin{tcolorbox}[ %
        colback=blue!5!white, % 
        colframe=blue!60!black, %
        title=\textsc{Example} %
    ] %
}{ %
    \end{tcolorbox} %
}

\chapter{Constraint-Based Algebraic Subtyping}
\label{algebraic-subtyping}

Part of the convenience of programming with dynamic typing is the absence of type annotations. 
This comfort comes at a price -- we cannot ensure any safety guarantees at compile-time. 
The aim of this thesis is to statically type languages with similar flexibility in mind. As such, we need to recover static types in the absence of annotations -- the mission statement of \textbf{type inference} \cite{tapl}.

In this chapter, I explore the problem of type inference for languages with structural subtyping. In doing so, I follow Dolan's seminal thesis on \textbf{algebraic subtyping} -- a type inference technique in the presence of subtyping and (bounded) parametric polymorphism. Specifically, I contribute the following:
\begin{itemize}
    \item A \textbf{constraint-based type inference framework} -- \inference{} -- based on the current state-of-the-art in algebraic subtyping. The framework does not fix specific type or expression languages -- it sets out some requirements for them (the \textit{signature}) and operates on a \emph{constraint language}. The constraint-based description is simple and direct, though formal and close to the implementation. 
    \item An extension of algebraic subtyping that supplements the type language with applications of \textbf{type lattice homomorphisms}, described for the framework. Using this extension, I give a method to statically type extensible records using algebraic subtyping -- a novel alternative to row polymorphism. 
\end{itemize}

We begin with background on type inference, including a review of the developments in algebraic subtyping (Section \ref{sec:ch3background}). The rest of the chapter's contents are the description of the framework. Firstly, in Section \ref{sec:signature} I give a description of the \textbf{signature} of the source language -- the requirements on the type language. Afterwards, in Section \ref{sec:constraints} I give the language of \textbf{constraints} and show how to solve them and extract solutions. Finally, I state and conjecture the correctness theorems of the framework in Section \ref{sec:correctness}. 

\begin{example}
    To ease understanding, the technical text of this chapter will be interleaved with boxes like this one, containing examples using Featherweight Lua (with some described extensions).
\end{example}

\section{Background}
\label{sec:ch3background}

Since this chapter concerns describing algebraic subtyping in the framework of constraint-based type inference, I explain these two concepts. We also set up the setting of the type inference problem we consider. 

\subsection{Type inference}
\emph{Type inference} (also called \emph{type reconstruction}), at its core, concerns determining the type $\tau$ of a given expression $e$ under an environment $\Gamma$, under some typing judgement $\Gamma \vdash e : \tau$.

\paragraph{Polymorphism \& type schemes} Type inference is (usually) straightforward in a \emph{simply-typed} setting. However, this is often insufficient -- for instance by considering the identity function $\mathrm{id} =  \lambda x \ldotp x$, which has type $\tau \to \tau$ for any type $\tau$.
This leads us to consider \textbf{parametric polymorphism}, where types contain type variables (denoted $\alpha, \beta, \gamma, \dots$), which can stand for any type. 
In this setting, expressions are not only given a type $\tau$, but a \textbf{type scheme} $\sch$ which can be \textbf{instantiated} to a type $\tau$ (written $\sch \models \tau$). A type scheme stands for any of these instantiations, and we define a judgement $\Gamma \vdash e : \sigma$ for ascribing a type scheme:
$$ \dfrac{\forall \tau \ldotp\; \sch \models \tau \implies \Gamma \vdash e : \tau}{\Gamma \vdash e : \sigma} $$

In this chapter, we will consider type inference in the presence of $F_\sub$-style \textbf{bounded} parametric polymorphism (in essence, \emph{bounded quantification} of \textcite{bounded-quantification}). Our type schemes $\sch$ have a form reminiscent of Java-style generics \cite{generic-java, simple-sub}:
$$ \sch ::= \forall \overline{\tau \sub \alpha \sub \tau} \ldotp \tau $$
where the body $\tau$ of $\sch$ must not contain unquantified type variables, and unspecified lower/upper bounds are presumed $\bot$/$\top$. 
Instantiation $\models$ derives from a type assignment $\psi ::= \cdot \mid \alpha : \tau, \psi$ for each free type variable $\alpha$, which satisfies the bounds (where we write $[\psi]\tau$ for a substitution under $\psi$):
$$ \dfrac{\overline{[\psi]\tau_\alpha^+ \sub \substx{\psi} \alpha \sub [\psi]\tau_\alpha^-}}{\forall \overline{\tau_\alpha^+ \sub \alpha \sub \tau_\alpha^-} \ldotp \tau \models \substx{\psi}{\tau}} $$
In particular, if $\sigma \models \tau$, then $\tau$ has no free type variables.

\begin{example}
    We extend FL with bounded parametric polymorphism from here onwards. 

    Consider $e = \fllam x\, \flproj{x}{\mathrm{foo}}$. Then we have both 
    $$ \cdot \vdash e : \forall \alpha, (\beta \sub \flrec{\mathrm{foo} : \alpha}) \ldotp \beta \to \alpha  \quad \text{and} \quad \cdot \vdash e : \underbrace{\forall  \alpha \ldotp \flrec{\mathrm{foo} : \alpha} \to \alpha}_\sigma $$
    And we have that $\sigma \models \flrec{\mathrm{foo} : \sint} \to \sint$ at $\sint/\alpha$.
    
    The existence of many valid type schemes points us to type scheme simplification -- here, we obtain the second type scheme by \emph{inlining} the bound on $\beta$ in the first. This is an important topic in type inference with subtyping, and one we consider at the end of Section \ref{subsec:simplification}.
\end{example}

We shall allow bounds $\tau_\alpha^+$/$\tau_\alpha^-$ in type schemes to refer to other type variables, which naturally leads us to including recursive types in the type language.
Specifically, we will consider type systems with \textbf{equirecursive types}, meaning they are infinite terms in the type language -- as opposed to isorecursive types, where recursive types are given by finite types which are (un)folded explicitly \cite{tapl}. We will write $\rec \alpha \tau$ for a type  such that instances of $\alpha$ are equal to the entire type.

\begin{example}
    We further extend FL with equirecursive $\mu$ types. 
    
    The type $\tau = \rec \alpha \top \to \alpha$ corresponds to the infinite type $\top \to (\top \to (\top \to \cdots)))$. Given $\cdot : e : \tau$ and $\cdot : e' : \top$ we have $\cdot : e\,e' : \tau$ -- $\tau$ is the type of a function that takes an infinite number of arguments.
\end{example}

We define two more concepts useful for dealing with type schemes: \emph{subsumption} and \emph{principality} (minimality). We define that $\sigma'$ \textbf{subsumes} $\sigma$, written $\sigma \subsume \sigma'$, as follows:
$$ \sigma \subsume \sigma' \iff \forall \tau \ldotp (\sigma \models \tau \impliedby \sigma' \models \tau) $$
meaning that $\sigma'$ admits all the types that $\sigma$ does.
Based on subsumption, we define the \textbf{principal} type scheme $\sigma$ for an expression $e$ as the one that subsumes all its other type schemes $\sigma'$ (it is minimal\footnote{When we take the preorder $\subsume$ on all type schemes $\sigma$ for which $\Gamma \vdash e : \sigma$.}), i.e.\@:
$$ \sigma\text{ principal} \iff \forall \sigma' \ldotp \left( \Gamma \vdash e : \sigma' \implies \sigma \subsume \sigma' \right) $$
Subsumption can be seen as a generalisation of subtyping to type schemes (given that the type scheme features an implicit subtyping rule). 

\begin{example}
    {\color{red} TODO} 
\end{example}

\paragraph{Constraint-based approach} While type schemes let us describe the \emph{result} of type inference, we can use \textbf{constraints} to describe type inference \emph{problems}. To this end, we follow the approach outlined in \citetitle{essence-of-ml-type-inference} by \textcite{essence-of-ml-type-inference} (\textcite[Chapter~10]{adv-tapl}).

This chapter will focus on constraint solving in the presence of subtyping, so we give an adequately simple constraint language in Figure \ref{fig:constraints} with only one predicate -- subtyping $\tau \sub \tau$, where types $\tau$ may contain type variables. We also feature constraint conjunction $c \und c$ and allow introducing existential variables $\exists \alpha \ldotp c$. The constraint satisfaction judgement $\psi \vdash c$ (where $\psi$ binds all free type variables in $c$) defined in Figure \ref{fig:satisfaction} gives a semantics to this syntax, specifying what variable assignments $\psi$ satisfy a given constraint $c$. In constraint solving nomenclature, we are dealing with a cylindric constraint system \cite{constraint-based-hm}. 

\begin{figure}
    \centering
    \begin{align*}
        \graintro c 
        \tru
        & \text{(always-true)}
        \graitem
        \fals
        & \text{(always-false)}
        \graitem
        \tau \sub \tau 
        & \text{(subtyping)}
        \graitem
        c \und c
         & \text{(conjunction)}
        \graitem 
        \exists \alpha \ldotp c
        & \text{(existential)}
    \end{align*}
    \caption{Syntax of constraints $c$ used in this chapter.}
    \label{fig:constraints}
\end{figure}

\begin{figure}
    \centering
    $$
    \irule{CTrue}{}{\psi \vdash \tru}
    \quad
    \irule{CSub}{\substx \psi \tau \sub \substx \psi \tau'}{\psi \vdash \tau \sub \tau'}
    \quad
    \irule{CAnd}{\psi \vdash c \quad \psi \vdash c'}{\psi \vdash c \und c'}
    \quad 
    \irule{CExist}{\psi, \tau/\alpha \vdash c}{\psi \vdash \exists \alpha \ldotp c}
    $$
    \caption{Constraint satisfaction judgement $\psi \vdash c$, defined for a type variable assignment $\psi$ and constraint $c$. Note that $\psi \vdash \fals$ is false for any $\psi$, while $\psi \vdash \tru$ is true for any $\psi$.}
    \label{fig:satisfaction}
\end{figure}
 
To construct a type inference problem as a constraint $c$ from an expression $e$ in the source language and its expected type $\tau$, we use \textbf{constraint generation} $\denot{e : \tau} = c$. Crucially, we require it agrees with typing:\footnote{Some standard presentations instead modify the type-scheme judgement to involve constraints, i.e.\@ $c; \Gamma \vdash e : \sigma$ \cite{essence-of-ml-type-inference}. For simplicity of the presentation, we take specific instantiations $\substx \psi \tau$, closer to e.g.\@ \cite[Section 3.4]{constraint-based-freeze-ml}.}
$$ \psi \vdash \denot{e : \tau} \iff \Gamma \vdash e : \substx \psi \tau $$

Since in type inference we do not know the specific type $\tau$, we can introduce it as a free variable in a constraint $\denot{e : \alpha}$. Analogously, if an expression contains `type holes' (like unannotated types of function parameters) these can be filled with type variables and constrained appropriately \cite{tapl}.

\begin{example}
    Consider $e = \fllam{x: \beta} \flproj{x}{\mathrm{quack}}\,\{\}$. Then we might have:
    $$ \denot{e : \alpha} = \exists \gamma \ldotp \beta \sub \flrec{\mathrm{quack}: \gamma} \und \exists \delta \ldotp \gamma \sub \flrec{} \to \delta \und \delta \sub \alpha $$
    where complete constraint generation for FL is defined in Appendix \ref{extra:fl-constraints}. Note that subtyping constraints and introduced type variables roughly follow the program dataflow \cite{mlsub}.

    We will later see this constraint system can be rewritten to $\exists \gamma \ldotp \flrec{\mathrm{quack} : \flrec{} \to \gamma} \to \gamma \sub \alpha$, and hence $\cdot \vdash e : \forall \gamma \ldotp \flrec{\mathrm{quack} : \flrec{} \to \gamma} \to \gamma$.
\end{example}

% It is worth noting here that this treatment of type inference is a bit different to the common Hindley-Milner type inference. There, we reason about unification and most general substitutions, but are also limited to an equality (rather than subtyping) predicate in constraints. Dolan's \emph{algebraic subtyping} (which we expand on in the next section) also reasoned about \emph{biunification} \emph{bisubstitutions}, more recent work moved towards a constraint-based approach, and this is the one we shall follow.

\subsection{Algebraic subtyping}

Combining bounded parametric polymorphism with both principal type inference and decidability of type scheme subsumption proved to be a difficult problem, which led to a general distrust in the presence of implicit subtyping in language design \cite{mlstruct} -- so much so that research would avoid subtyping due to its problematic interaction with type inference (see e.g.\@ \cite[Section~3.5]{linear-haskell}). Seminal work was due to \textcite{pottier-thesis}, who set out a framework for type inference under subtyping. This problem was ultimately resolved by \textcite{dolan-thesis} in his thesis.

\color{red}
\subsubsection{Dolan's original work}

The key aspects of Dolan's approach were to restrict the subtyping order to form a \textbf{distributive lattice} algebra and to impose the \textbf{polarity restriction} on types. Using these, \textcite{mlsub} gave a language design -- \mlsub{} -- with all the desired properties.

\paragraph{Distributive lattice} Like Dolan, we also consider a distributive lattice of types (with some extensions). This means that our type language contains meets $\meet$ (least upper bounds) and joins $\join$ (greatest lower bounds):
$$ \tau ::= \cdots \mid \tau \meet \tau \mid \tau \join \tau $$
where we consider types under an equivalence relation given by algebraic laws of the distributive lattice. 

\begin{example}
    We can compute the following for FL types:
    \begin{align*}
        (\top \to \bot) \meet (\alpha \to \beta) &= \top \to \bot \\ 
        \flext{\mathrm{quack} : \top, \mathrm{walk} : \flrec{}}{\flabsent} \meet \flext{\mathrm{quack} : \top \to \top}{\flftop} &= \flext{\mathrm{quack}: \top \to \top, \mathrm{walk}: \flrec{}}{\flabsent} \\ 
        \flrec{\mathrm{foo}: \flrec{}} \join (\top \to \top) &= \top
    \end{align*}
    where we take type variables in FL types as ground types \cite{tapl}. 
    
    We give complete definitions of meets and joins on FL types in Appendix \ref{extra:fl-constraints}.
\end{example}

\paragraph{Polarity restriction} The polarity restriction (used by both \textcite{dolan-thesis} and \textcite{pottier-thesis}) splits types $\tau$ into positive types $\tau^+$ and negative types $\tau^-$, so that we only consider subtyping constraints of form $\tau^+ \sub \tau^-$. Intuitively, positive types are used for \emph{outputs} (thus, we use them as a lower bound, e.g.\@ a function's result), while negative types are used for \emph{inputs} (upper bounds, e.g.\@ function's argument).

Crucially, \textcite{mlsub} not only adapt \mlsub{}'s type constructors to respect these polarities (in a manner matching their covariance/contravariance; e.g.\@ $\tau^+ ::= \cdots \mid \tau^- \to \tau^+$) -- this way, we only ever have subtyping constraints with matched polarities, i.e.\@ $\tau^+ \sub \tau^-$. Furthermore, they only permit joins in positive types, and meets in negative types:
$$ \tau^+ ::= \cdots \mid \tau^+ \join \tau^+ \quad \tau^- ::= \cdots \mid \tau^- \meet \tau^- $$
Together with the properties of the lattice algebra, this allows us to cleanly decompose and solve constraints $\tau^+ \sub \tau^-$ via the following pair of properties:
\begin{align*}
\tau' \join \tau'' \sub \tau \;&\iff \tau' \sub \tau \und \tau'' \sub \tau \\
\tau \sub \tau' \meet \tau'' \;&\iff \tau \sub \tau' \und \tau \sub \tau'' 
\end{align*}
This property of lattices remains crucial in approaches that follow algebraic subtyping.

However, the restriction of where meets and joins can occur in types -- and thus constraint solving -- means the language and its type system has to be carefully designed and certain types might not be expressible. 
Notionally, to type-check updating the field of a record, we will need a primitive of a form that further constrains the type to a subtype with the field updated:
$$ \forall \alpha, \beta \ldotp \alpha \to \alpha \land \flrec{\mathrm{foo}: \beta}  $$
Such a type breaks the polarity restriction, since a negative type (with a $\meet$) occurs in a positive position (since the inferred type of an expression is a lower bound).
Note this is not the type we actually use for typing extensible records, as there are problems with it -- we expand on this in Section \ref{sec:breaking-records}.

\paragraph{Formal treatment} Dolan's techniques revolved around the use of abstract algebra to prove the correctness of his techniques. For type inference itself, he parted with Pottier's constraint-oriented methods, and instead used biunification and bisubstitutions -- generalisation of standard notions in Hindley-Milner type inference to a setting with subtyping \cite{tapl, dolan-thesis}. 

\subsubsection{Later work}
The name \textbf{algebraic subtyping} refers to these restrictions and techniques that Dolan invented, but this report also uses the name for closely related methods which followed, particularly due to \textcite{simple-sub} (\simplesub{}) and \textcite{mlstruct} (\mlstruct{}). These methods are connected, particularly by assumptions about the subtyping order forming a well-behaved algebra of types. We now explain the significance of their work as expanding on Dolan.

\paragraph{\simplesub{}} 
Dolan's approach, although formally solid, leads to a complex implementation. This is shown by \textcite{simple-sub}, when they find demonstrable bugs in Dolan's reference implementation, and introduce a comparatively simpler approach operating on a \emph{constraint graph}. 

\paragraph{\mlstruct{}}
\color{black}

\subsection{Summary}


\section{Signature}
\label{sec:signature}

We consider the external side of the \inference{} framework -- the \emph{signature}, i.e.\@ the requirements it entails on the source language. 
All constructs described here are available as \textbf{data} upholding certain \textbf{laws} when we later describe constraints and how we solve them in Section~\ref{sec:constraints}. To this end, I mainly endeavour to generalise the properties that are necessary for the \mlstruct{} solver to work.

Firstly, following standard practice \cite{essence-of-ml-type-inference, constraint-based-freeze-ml},  we will abstract away type constructors in the type language as syntactic constructs. We will denote them $\constr[\overline \tau]$, where $\overline \tau$ stand for the list of types that occur within.
\begin{example}
    In FL we have the function and record type constructors. Writing \enquote{$\cdot$} for type holes in those constructors we may write:
    $$ \constr ::= \top \mid \bot \mid {\cdot} \to {\cdot} \mid \flext{\ell : \dot \phi}{\dot \phi} $$
    where $\dot \phi$ stands for field types where we leave a type hole in the present case, i.e.\@ we have:
    $$ \dot \phi ::= \flftop \mid \flfbot \mid \cdot \mid \flabsent $$
    Writing $\constr[\overline \tau]$, we plug in $\overline \tau$ in sequence in the constructor $\constr$ for \enquote{$\cdot$}s. Here are example types $\constr[\overline \tau]$:
    \begin{align*}  
        (\cdot \to \cdot)[\top, \bot] &= \top \to \bot \\
        \flext{\mathrm{foo}: \cdot, \mathrm{bar} : \flabsent}{\flftop}[\top \to \top] &= \flext{\mathrm{foo}: \top \to \top, \mathrm{bar} : \flabsent}{\flftop}
    \end{align*}
    With this setup, we establish that type constructors $\constr$ contain type terms $\tau$ as subterms, rather than keeping them opaque. 
\end{example}
We will require that type constructors $\constr[\overline \tau]$ form a distributive lattice $(\top, \bot, \cjoin, \cmeet)$, where $\top$ and $\bot$ are nullary type constructors and $\cjoin$ and $\cmeet$ are closed binary operators on type constructors. Furthermore, we require a \textbf{decomposition} operator $\constr[\overline \tau] \cdecomp \constr[\overline \tau] = c$, which decomposes a subtyping constraint between two type constructors into an equivalent one:
$$ \psi \vdash \constr[\overline \tau] \sub \constr'[\overline \tau'] \iff \psi \vdash \constr[\overline \tau] \cdecomp \constr'[\overline \tau'] $$
where the resulting constraints contain structurally smaller type constructors.\footnote{We do not formalise this property, but it would be necessary to do so to prove the constraint solving process terminates.} Together with the type constructor lattice and constraint decomposition we will be able to effectively massage constraints involving type constructors. 
\begin{example}
    The type constructor lattice given by $\cmeet$ and $\cjoin$ agrees with $\meet$ and $\join$ on types we considered before:
    \begin{align*}
       (\top \to \top) \meet (\bot \to \bot) 
       &= (\cdot \to \cdot)[\top, \top] \cmeet (\cdot \to \cdot)[\bot, \bot] = (\cdot \to \cdot)[\top \cjoin \bot, \top \cmeet \bot] \\
       &= (\cdot \to \cdot)[\top, \bot] = \top \to \bot 
    \end{align*}
    Constraints on function constructors decompose as such:
    $$ (\tau \to \pi) \cdecomp (\tau' \to \pi') = \tau' \sub \tau \und \pi \sub \pi' $$
\end{example}

\begin{figure}
    \centering
    \begin{align*}
    \graintro \tau 
             \alpha & \text{(type variable)}
    \graitem \constr[\overline \tau] & \text{(type constructor)}
    \graitem \tau \join \tau & \text{(join)}
    \graitem \tau \join \tau & \text{(join)}
    \graitem \tau \meet \tau & \text{(meet)}
    \graitem \lnot \tau & \text{(complement)}
    \end{align*}
    \caption{Syntax of types $\tau$ in \inference{}.}
    \label{fig:types}
\end{figure}

\begin{figure}
    \centering
    % $$ \mathbb B = (\tau, \sub, \top, \bot, \join, \meet) $$ 
    $$ \renewcommand\arraystretch{1.1} \begin{array}{cr}
    \tau \join (\tau' \join \tau'') \equiv (\tau \join \tau') \join \tau'' \quad 
    & \text{(associativity \mbox{$\join$})}
    \\
    \tau \meet (\tau' \meet \tau'') \equiv (\tau \meet \tau') \meet \tau''
    \tau \join \tau' \equiv \tau' \join \tau  \quad 
    & \text{(associativity \mbox{$\meet$})} 
    \\
    \quad
    \tau \meet \tau' \equiv \tau' \meet \tau 
    & \text{(commutativity)}
    \\
    \tau \join (\tau \meet \tau') = \tau
    \quad 
    \tau \meet (\tau \join \tau') = \tau
    & \text{(absorption)}
    \\ 
    \tau \join \bot \equiv \tau
    \quad 
    \tau \meet \top \equiv \tau 
    & \text{(bounds)} 
    \\
    \tau \meet (\tau_1 \join \tau_2) \equiv (\tau \meet \tau_1) \join (\tau \meet \tau_2)
    & \text{(distributivity)}
    \\
    \tau \join \comp \tau = \top 
    \quad
    \tau \meet \comp \tau = \bot
    & \text{(complements)}
    \end{array} $$
    \caption{Laws of the Boolean algebra of types, over which we quotient equality over types $\tau$. Each of the last three lines introduces the laws of (in order): a bounded lattice, a distributive lattice, and a complemented (Boolean) lattice.}
    \label{fig:boolean-laws}
\end{figure}

With the necessary structure of type constructors, we can turn to describe the syntax of types itself. Following \textcite{mlstruct}, we define it so that it forms the free Boolean algebra (satisfying laws in Figure \ref{fig:boolean-laws}) over type constructors and type variables\footnote{Like \textcite{dolan-thesis}, our type variables are \emph{opaque} in the type lattice, and we do not make a closed-world assumption about their possible values.} with homomorphisms $\morph$. The syntax of types is given in Figure \ref{fig:types}. We additionally quotient types $\tau$ by equivalence under equations of the type constructor lattice.  
The subtyping order $\sub$ must agree with this type algebra:
$$ \tau \sub \pi \iff \tau = \tau \meet \pi \iff \pi = \tau \join \pi $$

\section{Constraints}
\label{sec:constraints}

We now describe the \mlstruct{}-inspired constraint solving process used in \inference{} using the already described setting of the constraint language.

\subsection{Rewriting}
\label{subsec:rewriting}

\subsection{Normalisation}
\label{subsec:normalisation}

\subsection{Solutions}
\label{subsec:solutions}

\subsection{Simplification}
\label{subsec:simplification}

\section{Breaking records: Homomorphism extension}
\label{sec:breaking-records}

A crucial problem with typing record extension with a subtyping-based approach, rather than one with row-polymorphism, is that it is difficult to manipulate (e.g.\@ project) a specific field of an existing record solely through subtyping constraints. This leads us to the idea that it would be convenient to have \emph{type-level functions} which would perform this sort of manipulation. 

I propose to follow the algebraic approach and exploit homomorphisms in the type algebra -- indeed, well-behaved functions on types -- for this purpose. Thanks to homomorphism laws (plus some extra structure we require), we are able to successfully manipulate them in constraint solving, and they thus uncover a new direction in type systems designs when applying algebraic subtyping.

\begin{example}
    For typing extensible records, we shall later develop a homomorphism $\mathrm{forget}_\ell$, which given a record type sends a given field $\ell$ to $\flftop$.
    By sending the field $\ell$ to $\flftop$ (the top of field types), we can then intersect the result with a singleton of $\ell$ in order to set it to a wanted field type, since $\flftop \meet \phi = \phi$. 
    
    For example:
    \setlength{\tabcolsep}{0pt}
    $$\begin{array}{rll}
        &\hspace{-0.9em}\tau &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \flabsent}{\flabsent} \\
        \mathrm{forget}_\mathrm{foo}( &\hspace{-0.9em}\tau ) &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \flftop}{\flabsent} \\
        \mathrm{forget}_\mathrm{foo}( &\hspace{-0.9em}\tau ) \meet \flext{\mathrm{foo}: \alpha}{\flftop} &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \alpha}{\flabsent}
    \end{array}$$
    This shows how we will replace an absent field in a record with one present with $\alpha$.

    This is reminiscent of the retraction operator on record types of \textcite{operations-on-records}.
\end{example}

\begin{figure}
    \centering
    \begin{align*}
        \morph(\tau \meet \pi) &= \morph(\tau) \meet \morph(\pi) \\
        \morph(\tau \join \pi) &= \morph(\tau) \join \morph(\pi) \\
        \morph(\top) &= \top \\
        \morph(\bot) &= \bot
    \end{align*}
    \caption{Homomorphism laws in the Boolean algebra of laws, with which we quotient equality over types $\tau$ involving homomorphism applications. Note that $\morph(\comp \tau) = \comp \morph(\tau)$ follows from these laws.}
    \label{fig:morphism-laws}
\end{figure}

We develop this idea formally by first extending the syntax of types with \textbf{homomorphism applications} for some homomorphisms $\morph$ (specific to a language), including a homomorphism $\morph = \mathrm{id}$:
$$ \tau ::= \cdots \mid \morph(\tau) $$
requiring that equality of types respects the homomorphism laws (given in Figure \ref{fig:morphism-laws}) and that $\mathrm{id}(\tau) = \tau$. 

In order to solve constraints in the presence of homomorphism applications, we require they have an \emph{adjoint-like}\footnote{Or, perhaps better said, Galois connection-like -- though adjoint is a convenient name.} structure given by left- and right-adjoints $\ladj \morph$ and $\radj \morph$ for morphisms. In practice, not all homomorphisms have an adjoint structure (which is why we call it adjoint-like), thus we also allow \emph{remainders} $\ladjrest \morph$ and $\radjrest \morph$, so that we have the pair of constraint equivalences:
\begin{align*}
\psi \vdash \morph(\tau) \sub \pi &\;\iff \psi \vdash \tau \sub \radj \morph(\pi) \und \radjrest \morph(\pi) \\
\psi \vdash \tau \sub \morph(\pi) &\;\iff \psi \vdash \ladj \morph(\tau) \sub \pi \und \ladjrest \morph(\tau)
\end{align*}
The use of $\ladjrest \morph$ and $\radjrest \morph$ makes it clear why we call these remainders: in the degenerate case that they introduce no further constraint ($\ladjrest \morph = \radjrest \morph = \tru$), $\ladjrest \morph$ and $\radjrest \morph$ are precisely left and right Galois connections to $\morph$.

\section{Correctness}
\label{sec:correctness}

\section{Conclusions}
\label{sec:conclusions}

The description of \inference{} in this chapter can be seen as sufficient to instantiate an existing constraint-based type inference framework like $\mathrm{HM}(X)$ of \textcite{constraint-based-hm}. Thus, we do not consider let-polymorphism here -- as is typical of Hindley-Milner systems modelled by $\mathrm{HM}(X)$ -- and focus on the presentation of constraint solving.


