\newcommand{\mlsub}{\textsc{MLsub}}
\newcommand{\simplesub}{\textsc{Simple-sub}}
\newcommand{\mlstruct}{\textsc{MLstruct}}
\newenvironment{example}{ %
    \begin{tcolorbox}[ %
        colback=blue!5!white, % 
        colframe=blue!60!black, %
        title=\textsc{Example} %
    ] %
}{ %
    \end{tcolorbox} %
}

\chapter{Constraint-Based Algebraic Subtyping}
\label{algebraic-subtyping}

Part of the convenience of programming with dynamic typing is the absence of type annotations. 
This comfort comes at a price -- we cannot ensure any safety guarantees at compile-time. 
The aim of this thesis is to statically type languages with similar flexibility in mind. As such, we need to recover static types in the absence of annotations -- to have \emph{implicit typing} \cite{remy-record-inference}). This is the mission statement of \textbf{type inference} \cite{tapl}.

In this chapter, I explore the problem of type inference for languages with structural subtyping. In doing so, I follow Dolan's seminal thesis on \textbf{algebraic subtyping} -- a type inference technique in the presence of subtyping and (bounded) parametric polymorphism. Specifically, I contribute the following:
\begin{itemize}
    \item A \textbf{constraint-based type inference framework} -- \inference{} -- based on the current state-of-the-art in algebraic subtyping. The framework does not fix specific type or expression languages -- it sets out some requirements for them (the \textit{signature}) and operates on an intermediate \emph{constraint language}. The constraint-based description is simple and direct, though formal and close to the implementation. As such, it is a step towards understanding when we can apply algebraic subtyping in practice.
    \item An extension of algebraic subtyping that supplements the type language with applications of \textbf{type lattice homomorphisms}, described for the framework. Using this extension, I give a method to statically type extensible records using algebraic subtyping -- a novel alternative to row polymorphism. 
\end{itemize}

We begin with background on type inference, including our constraint-based setting and a review of the developments in algebraic subtyping (Section \ref{sec:ch3background}).The rest of the chapter's contents are the description of the framework. Firstly, in Section \ref{sec:signature} I give a description of the \textbf{signature} of the source language -- the requirements on the type language. Afterwards, in Section \ref{sec:constraints} I explain the \textbf{constraint solving} approach in \inference{}, and show the homomorphism extension in Section \ref{sec:morphisms}. Finally, I state and conjecture the correctness theorems of the framework in Section \ref{sec:correctness}. 

\begin{example}
    To ease understanding, the technical text of this chapter will be interleaved with boxes like this one, containing examples using Featherweight Lua (with some described extensions).
\end{example}

\section{Background}
\label{sec:ch3background}

Since this chapter concerns describing algebraic subtyping in the framework of constraint-based type inference, I explain these two concepts. We also set up the setting of the type inference problem we consider. 

\subsection{Type inference}
\emph{Type inference} (also called \emph{type reconstruction}), at its core, concerns determining the type $\tau$ of a given expression $e$ under an environment $\Gamma$, under some typing judgement $\Gamma \vdash e : \tau$.

\paragraph{Polymorphism \& type schemes} Type inference is (usually) straightforward in a \emph{simply-typed} setting. However, this is often insufficient -- for instance by considering the identity function $\mathrm{id} =  \lambda x \ldotp x$, which has type $\tau \to \tau$ for any type $\tau$.
This leads us to consider \textbf{parametric polymorphism}, where types contain type variables (denoted $\alpha, \beta, \gamma, \dots$), which can stand for any type. 
In this setting, expressions are not only given a type $\tau$, but a \textbf{type scheme} $\sch$ which can be \textbf{instantiated} to a type $\tau$ (written $\sch \models \tau$). A type scheme stands for any of these instantiations, and we define a judgement $\Gamma \vdash e : \sigma$ for ascribing a type scheme:
$$ \dfrac{\forall \tau \ldotp\; \sch \models \tau \implies \Gamma \vdash e : \tau}{\Gamma \vdash e : \sigma} $$

In this chapter, we will consider type inference in the presence of $F_\sub$-style \textbf{bounded} parametric polymorphism (in essence, \emph{bounded quantification} of \textcite{bounded-quantification}). Our type schemes $\sch$ have a form reminiscent of Java-style generics \cite{generic-java, simple-sub}:
$$ \sch ::= \forall \overline{\tau \sub \alpha \sub \tau} \ldotp \tau $$
where the body $\tau$ of $\sch$ must not contain unquantified type variables, and unspecified lower/upper bounds are presumed $\bot$/$\top$. 
Instantiation $\models$ derives from a type assignment $\psi ::= \cdot \mid \tau/\alpha$, which satisfies the bounds for each free type variable $\alpha$. Writing $[\psi]\tau$ for a substitution in $\tau$ under $\psi$, we have:
$$ \dfrac{\overline{[\psi]\tau_\alpha^+ \sub \substx{\psi} \alpha \sub [\psi]\tau_\alpha^-}}{\forall \overline{\tau_\alpha^+ \sub \alpha \sub \tau_\alpha^-} \ldotp \tau \models \substx{\psi}{\tau}} $$
In particular, if $\sigma \models \tau$, then $\tau$ has no free type variables.

\begin{example}
    We extend FL with bounded parametric polymorphism from here onwards. 

    Consider $e = \fllam x\, \flproj{x}{\mathrm{foo}}$. Then we have both 
    $$ \cdot \vdash e : \forall \alpha, (\beta \sub \flrec{\mathrm{foo} : \alpha}) \ldotp \beta \to \alpha  \quad \text{and} \quad \cdot \vdash e : \underbrace{\forall  \alpha \ldotp \flrec{\mathrm{foo} : \alpha} \to \alpha}_\sigma $$
    And we have that $\sigma \models \flrec{\mathrm{foo} : \sint} \to \sint$ at $\sint/\alpha$.
    
    The existence of many valid type schemes points us to type scheme simplification -- here, we obtain the second type scheme by \emph{inlining} the bound on $\beta$ in the first. This is an important topic in type inference with subtyping, and one we consider at the end of Section \ref{subsec:simplification}.
\end{example}

We shall allow bounds $\tau_\alpha^+$/$\tau_\alpha^-$ in type schemes to refer to other type variables, which naturally leads us to including recursive types in the type language.
Specifically, we will consider type systems with \textbf{equirecursive types}, meaning they are infinite terms in the type language -- as opposed to isorecursive types, where recursive types are given by finite types which are (un)folded explicitly \cite{tapl}. We will write $\rec \alpha \tau$ for a type  such that instances of $\alpha$ are equal to the entire type.

\begin{example}
    We further extend FL with equirecursive $\mu$ types. 
    The type $\tau = \rec \alpha \top \to \alpha$ corresponds to the infinite type $\top \to (\top \to (\top \to \cdots)))$. Given $\cdot : e : \tau$ and $\cdot : e' : \top$ we have $\cdot : e\,e' : \tau$. Hence, $\tau$ is the type of a function that takes an infinite number of arguments.
\end{example}

We define two more concepts useful for dealing with type schemes: \emph{subsumption} and \emph{principality} (minimality). We define that $\sigma'$ \textbf{subsumes} $\sigma$, written $\sigma \subsume \sigma'$, as follows:
$$ \sigma \subsume \sigma' \iff \forall \tau \ldotp (\sigma \models \tau \impliedby \sigma' \models \tau) $$
meaning that $\sigma'$ admits all the types that $\sigma$ does.
Based on subsumption, we define the \textbf{principal} type scheme $\sigma$ for an expression $e$ as the one that subsumes all its other type schemes $\sigma'$ (it is minimal\footnote{When we take the preorder $\subsume$ on all type schemes $\sigma$ for which $\Gamma \vdash e : \sigma$.}), i.e.\@:
$$ \sigma\text{ principal} \iff \forall \sigma' \ldotp \left( \Gamma \vdash e : \sigma' \implies \sigma \subsume \sigma' \right) $$
Subsumption can be seen as a generalisation of subtyping to type schemes (given that the type scheme features an implicit subtyping rule). 

\begin{example}
    {\color{red} TODO} 
\end{example}

\paragraph{Constraint-based approach} While type schemes let us describe the \emph{result} of type inference, we can use \textbf{constraints} to describe type inference \emph{problems}. To this end, we follow the approach outlined in \citetitle{essence-of-ml-type-inference} by \textcite{essence-of-ml-type-inference} (\textcite[Chapter~10]{adv-tapl}).

This chapter will focus on constraint solving in the presence of subtyping, so we give an adequately simple constraint language in Figure \ref{fig:constraints} with only one predicate -- subtyping $\tau \sub \tau$, where types $\tau$ may contain type variables. We also feature constraint conjunction $c \und c$ and allow introducing existential variables $\exists \alpha \ldotp c$. The constraint satisfaction judgement $\psi \vdash c$ (where $\psi$ binds all free type variables in $c$) defined in Figure \ref{fig:satisfaction} gives a semantics to this syntax, specifying what variable assignments $\psi$ satisfy a given constraint $c$. In constraint solving nomenclature, we are dealing with a cylindric constraint system \cite{constraint-based-hm}. 

\begin{figure}
    \centering
    \begin{align*}
        \graintro c 
        \tru
        & \text{(always-true)}
        \graitem
        \fals
        & \text{(always-false)}
        \graitem
        \tau \sub \tau 
        & \text{(subtyping)}
        \graitem
        c \und c
         & \text{(conjunction)}
        \graitem 
        \exists \alpha \ldotp c
        & \text{(existential)}
    \end{align*}
    \caption{Syntax of constraints $c$ used in this chapter.}
    \label{fig:constraints}
\end{figure}

\begin{figure}
    \centering
    $$
    \irule{CTrue}{}{\psi \vdash \tru}
    \quad
    \irule{CSub}{\substx \psi \tau \sub \substx \psi \tau'}{\psi \vdash \tau \sub \tau'}
    \quad
    \irule{CAnd}{\psi \vdash c \quad \psi \vdash c'}{\psi \vdash c \und c'}
    \quad 
    \irule{CExist}{\psi, \tau/\alpha \vdash c}{\psi \vdash \exists \alpha \ldotp c}
    $$
    \caption{Constraint satisfaction judgement $\psi \vdash c$, defined for a type variable assignment $\psi$ and constraint $c$. Note that $\psi \vdash \fals$ is false for any $\psi$ ($\fals$ signals failure of inference -- type errors), and $\psi \vdash \tru$ is true for any $\psi$.}
    \label{fig:satisfaction}
\end{figure}
 
To construct a type inference problem as a constraint $c$ from an expression $e$ in the source language and its expected type $\tau$, we use \textbf{constraint generation} $\denot{e : \tau} = c$. Crucially, we require it agrees with typing:\footnote{Some standard presentations instead modify the type-scheme judgement to involve constraints, i.e.\@ $c; \Gamma \vdash e : \sigma$ \cite{essence-of-ml-type-inference}. For simplicity of the presentation, we take specific instantiations $\substx \psi \tau$, closer to e.g.\@ \cite[Section 3.4]{constraint-based-freeze-ml}.}
$$ \psi \vdash \denot{e : \tau} \iff \Gamma \vdash e : \substx \psi \tau $$

Since in type inference we do not know the specific type $\tau$, we can introduce it as a free variable in a constraint $\denot{e : \alpha}$. Analogously, if an expression contains `type holes' (like unannotated types of function parameters) these can be filled with type variables and constrained appropriately \cite{tapl}.

\begin{example}
    Consider $e = \fllam{x: \beta} \flproj{x}{\mathrm{quack}}\,\{\}$. Then we might have:
    $$ \denot{e : \alpha} = \exists \gamma \ldotp \beta \sub \flrec{\mathrm{quack}: \gamma} \und \exists \delta \ldotp \gamma \sub \flrec{} \to \delta \und \delta \sub \alpha $$
    where complete constraint generation for FL is defined in Appendix \ref{extra:fl-constraints}. Note that subtyping constraints and introduced type variables roughly follow the program dataflow \cite{mlsub}.

    We will later see this constraint system can be rewritten to $\exists \gamma \ldotp \flrec{\mathrm{quack} : \flrec{} \to \gamma} \to \gamma \sub \alpha$, and hence $\cdot \vdash e : \forall \gamma \ldotp \flrec{\mathrm{quack} : \flrec{} \to \gamma} \to \gamma$.
\end{example}\todo[color=green]{extra}

% It is worth noting here that this treatment of type inference is a bit different to the common Hindley-Milner type inference. There, we reason about unification and most general substitutions, but are also limited to an equality (rather than subtyping) predicate in constraints. Dolan's \emph{algebraic subtyping} (which we expand on in the next section) also reasoned about \emph{biunification} \emph{bisubstitutions}, more recent work moved towards a constraint-based approach, and this is the one we shall follow.

\subsection{Algebraic subtyping}

Combining bounded parametric polymorphism with both principal type inference and decidability of type scheme subsumption proved to be a difficult problem, which led to a general distrust in the presence of implicit subtyping in language design \cite{mlstruct} -- so much so that research would avoid subtyping due to its problematic interaction with type inference (see e.g.\@ \cite[Section~3.5]{linear-haskell}). Seminal work was due to \textcite{pottier-thesis}, who set out a framework for type inference under subtyping. This problem was ultimately resolved by \textcite{dolan-thesis} in his thesis.

\color{red}
\subsubsection{Dolan's original work}

The key aspects of Dolan's approach were to restrict the subtyping order to form a \textbf{distributive lattice} algebra and to impose the \textbf{polarity restriction} on types. Using these, \textcite{mlsub} gave a language design -- \mlsub{} -- with all the desired properties.

\paragraph{Distributive lattice} Like Dolan, we also consider a distributive lattice of types (with some extensions). This means that our type language contains meets $\meet$ (least upper bounds) and joins $\join$ (greatest lower bounds):
$$ \tau ::= \cdots \mid \tau \meet \tau \mid \tau \join \tau $$
where we consider types under an equivalence relation given by algebraic laws of the distributive lattice. 

\begin{example}
    We can compute the following for FL types:
    \begin{align*}
        (\top \to \bot) \meet (\alpha \to \beta) &= \top \to \bot \\ 
        \flext{\mathrm{quack} : \top, \mathrm{walk} : \flrec{}}{\flabsent} \meet \flext{\mathrm{quack} : \top \to \top}{\flftop} &= \flext{\mathrm{quack}: \top \to \top, \mathrm{walk}: \flrec{}}{\flabsent} \\ 
        \flrec{\mathrm{foo}: \flrec{}} \join (\top \to \top) &= \top
    \end{align*}
    where we take type variables in FL types as ground types \cite{tapl}. 
    
    We give complete definitions of meets and joins on FL types in Appendix \ref{extra:fl-constraints}.
\end{example}\todo[color=green]{extra}

\paragraph{Polarity restriction} The polarity restriction (used by both \textcite{dolan-thesis} and \textcite{pottier-thesis}) splits types $\tau$ into positive types $\tau^+$ and negative types $\tau^-$, so that we only consider subtyping constraints of form $\tau^+ \sub \tau^-$. Intuitively, positive types are used for \emph{outputs} (thus, we use them as a lower bound, e.g.\@ a function's result), while negative types are used for \emph{inputs} (upper bounds, e.g.\@ function's argument).

Crucially, \textcite{mlsub} not only adapt \mlsub{}'s type constructors to respect these polarities (in a manner matching their covariance/contravariance; e.g.\@ $\tau^+ ::= \cdots \mid \tau^- \to \tau^+$) -- this way, we only ever have subtyping constraints with matched polarities, i.e.\@ $\tau^+ \sub \tau^-$. Furthermore, they only permit joins in positive types, and meets in negative types:
$$ \tau^+ ::= \cdots \mid \tau^+ \join \tau^+ \quad \tau^- ::= \cdots \mid \tau^- \meet \tau^- $$
Together with the properties of the lattice algebra, this allows us to cleanly decompose and solve constraints $\tau^+ \sub \tau^-$ via the following pair of properties:
\begin{align*}
\tau' \join \tau'' \sub \tau \;&\iff \tau' \sub \tau \und \tau'' \sub \tau \\
\tau \sub \tau' \meet \tau'' \;&\iff \tau \sub \tau' \und \tau \sub \tau'' 
\end{align*}
This property of lattices remains crucial in approaches that follow algebraic subtyping.

However, the restriction of where meets and joins can occur in types -- and thus constraint solving -- means the language and its type system has to be carefully designed and certain types might not be expressible. 
Notionally, to type-check updating the field of a record, we will need a primitive of a form that further constrains the type to a subtype with the field updated:
$$ \forall \alpha, \beta \ldotp \alpha \to \alpha \land \flrec{\mathrm{foo}: \beta}  $$
Such a type breaks the polarity restriction, since a negative type (with a $\meet$) occurs in a positive position (since the inferred type of an expression is a lower bound).
Note this is not the type we actually use for typing extensible records, as there are problems with it -- we expand on this in Section \ref{sec:morphisms}.

\paragraph{Formal treatment} Dolan's techniques revolved around the use of abstract algebra to prove the correctness of his techniques. For type inference itself, he parted with Pottier's constraint-oriented methods, and instead used biunification and bisubstitutions -- generalisation of standard notions in Hindley-Milner type inference to a setting with subtyping \cite{tapl, dolan-thesis}. 

\subsubsection{Later work}
The name \textbf{algebraic subtyping} refers to these restrictions and techniques that Dolan invented, but this report also uses the name for closely related methods which followed, particularly due to \textcite{simple-sub} (\simplesub{}) and \textcite{mlstruct} (\mlstruct{}). These methods are connected, particularly by assumptions about the subtyping order forming a well-behaved algebra of types. We now explain the significance of their work as expanding on Dolan.

\paragraph{\simplesub{}} 
Dolan's approach, although formally solid, leads to a complex implementation. This is shown by \textcite{simple-sub}, when they find demonstrable bugs in Dolan's reference implementation, and introduce a comparatively simpler approach operating on a \emph{constraint graph}. 

\color{black}

\section{Signature}
\label{sec:signature}

We consider the external side of the \inference{} framework -- the \emph{signature}, i.e.\@ the requirements it entails on the source language. 
All constructs described here are available as \textbf{data} upholding certain \textbf{laws} when we later describe constraints and how we solve them in Section~\ref{sec:constraints}. To this end, I mainly endeavour to generalise the properties that are necessary for the \mlstruct{} solver to work.

Firstly, following standard practice \cite{essence-of-ml-type-inference, constraint-based-freeze-ml},  we will abstract away type constructors in the type language as syntactic constructs. We will denote them $\constr[\overline \tau]$, where $\overline \tau$ stand for the list of types that occur within.
\begin{example}
    In FL we have the function and record type constructors. Writing \enquote{$\cdot$} for \emph{type holes} in constructors:
    $$ \constr ::= \top \mid \bot \mid {\cdot} \to {\cdot} \mid \flext{\ell : \dot \phi}{\dot \phi} $$
    where $\dot \phi$ stands for field types where we leave a type hole in the present case, i.e.\@ we have:
    $$ \dot \phi ::= \flftop \mid \flfbot \mid \cdot \mid \flabsent $$
    Writing $\constr[\overline \tau]$, we plug in $\overline \tau$ into each \enquote{$\cdot$} in $\constr$ in order. Here are example types $\constr[\overline \tau]$:
    \begin{align*}  
        (\cdot \to \cdot)[\top, \bot] &= \top \to \bot \\
        \flext{\mathrm{foo}: \cdot, \mathrm{bar} : \flabsent}{\flftop}[\top \to \top] &= \flext{\mathrm{foo}: \top \to \top, \mathrm{bar} : \flabsent}{\flftop}
    \end{align*}
    With this setup, we establish that type constructors $\constr$ contain type terms $\tau$ as subterms, rather than keeping them opaque. 
\end{example}
We will require that type constructors $\constr[\overline \tau]$ form a distributive lattice $(\top, \bot, \cjoin, \cmeet)$, where $\top$ and $\bot$ are nullary type constructors and $\cjoin$ and $\cmeet$ are closed binary operators on type constructors. Furthermore, we require a \textbf{decomposition} operator $\constr[\overline \tau] \cdecomp \constr[\overline \tau] = c$, which decomposes a subtyping constraint between two type constructors into an equivalent one:
$$ \psi \vdash \constr[\overline \tau] \sub \constr'[\overline \tau'] \iff \psi \vdash \constr[\overline \tau] \cdecomp \constr'[\overline \tau'] $$
where the resulting constraints contain structurally smaller type constructors.\footnote{We do not formalise this property, but it would be necessary to do so to prove the constraint solving process terminates.} Decomposition is where type errors may be raised in the system, e.g.\@ in the case $\top \cdecomp \bot = \fals$. Together with the type constructor lattice and constraint decomposition we will be able to effectively massage constraints involving type constructors. 
\begin{example}
    The type constructor lattice given by $\cmeet$ and $\cjoin$ agrees with $\meet$ and $\join$ on types, e.g.:
    \begin{align*}
       (\top \to \top) \meet (\bot \to \bot) 
       &\equiv (\cdot \to \cdot)[\top, \top] \cmeet (\cdot \to \cdot)[\bot, \bot] = (\cdot \to \cdot)[\top \cjoin \bot, \top \cmeet \bot] \\
       &= (\cdot \to \cdot)[\top, \bot] \equiv \top \to \bot 
    \end{align*}
    Constraints on function type constructors decompose as such:
    $$ (\tau \to \pi) \cdecomp (\tau' \to \pi') = \tau' \sub \tau \und \pi \sub \pi' $$
\end{example}

\begin{figure}
    \centering
    \begin{align*}
    \graintro \tau 
             \alpha & \text{(variable)}
    \graitem \constr[\overline \tau] & \text{(constructor)}
    \graitem \tau \join \tau & \text{(join)}
    \graitem \tau \join \tau & \text{(join)}
    \graitem \tau \meet \tau & \text{(meet)}
    \graitem \lnot \tau & \text{(complement)}
    \end{align*}
    \caption{Syntax of types $\tau$ in \inference{}.}
    \label{fig:signature-types}
\end{figure}

\begin{figure}
    \centering
    % $$ \mathbb B = (\tau, \sub, \top, \bot, \join, \meet) $$ 
    $$ \boxed{\tau \equiv \tau} $$
    $$ \renewcommand\arraystretch{1.1} \begin{array}{cr}
    \tau \join (\tau' \join \tau'') \equiv (\tau \join \tau') \join \tau'' \quad 
    & \text{(associativity \mbox{$\join$})}
    \\
    \tau \meet (\tau' \meet \tau'') \equiv (\tau \meet \tau') \meet \tau''
    \tau \join \tau' \equiv \tau' \join \tau  \quad 
    & \text{(associativity \mbox{$\meet$})} 
    \\
    \quad
    \tau \meet \tau' \equiv \tau' \meet \tau 
    & \text{(commutativity)}
    \\
    \tau \join (\tau \meet \tau') = \tau
    \quad 
    \tau \meet (\tau \join \tau') = \tau
    & \text{(absorption)}
    \\ 
    \tau \join \bot \equiv \tau
    \quad 
    \tau \meet \top \equiv \tau 
    & \text{(bounds)} 
    \\
    \tau \meet (\tau' \join \tau'') \equiv (\tau \meet \tau') \join (\tau \meet \tau'')
    & \text{(distributivity)}
    \\
    \tau \join \comp \tau = \top 
    \quad
    \tau \meet \comp \tau = \bot
    & \text{(complements)} 
    \\ 
    T_1\left[\overline {\tau'}\right] \join T_2\left[\overline {\tau''}\right] \equiv T_1\left[\overline {\tau'}\right] \cjoin T_2\left[\overline {\tau''}\right]
    & \text{(type constructor $\cjoin$/$\join$)}
    \\
    T_1\left[\overline {\tau'}\right] \meet T_2\left[\overline {\tau''}\right] \equiv T_1\left[\overline {\tau'}\right] \cmeet T_2\left[\overline {\tau''}\right]
    & \text{(type constructor $\cmeet$/$\meet$)}
    \\[0.5em] 
    \dfrac{\tau \equiv \tau'}{E[\tau] \equiv E[\tau']} 
    & \text{(congruence)}
    \end{array} $$
    $$ \equivctx ::= \ctxhole \mid T[\overline \tau, \ctxhole, \overline \tau] \mid \equivctx \join \tau \mid \tau \join \equivctx \mid \equivctx \meet \tau \mid \tau \meet \equivctx \mid \comp \equivctx $$
    \caption{Laws of the Boolean algebra of types and the lattice of type constructors, forming the equivalence $\tau \equiv \tau$. Equivalence contexts $\equivctx$ are used to specify the congruence rule.}
    \label{fig:boolean-laws}
\end{figure}

With the necessary structure of type constructors, we can turn to describe the syntax of types itself. Following \textcite{mlstruct}, we define the syntax of types (Figure \ref{fig:signature-types}) so that it forms the free Boolean algebra over type constructors and type variables\footnote{Like \textcite{dolan-thesis}, our variables are \emph{opaque} in the lattice -- we do not make a closed-world assumption about their possible values.}. We require this algebra satisfies both Boolean algebra laws, including laws of the type constructor lattice (Figure \ref{fig:boolean-laws}).\footnote{Following this, the algebra of types is free extension of the algebra of type constructors with variables and complements.} As a coherence condition, the subtyping order $\sub$ must agree with the type algebra:
$$ \tau \sub \pi \iff \tau \equiv \tau \meet \pi \iff \pi \equiv \tau \join \pi $$
Lastly, the subtyping must indeed agree with the typing judgement:
$$ \dfrac{\Gamma \vdash e : \tau \quad \tau \sub \tau'}{\Gamma \vdash e : \tau'}  $$

\paragraph{Inclusion of complement types} Complement (or negation) types are a somewhat controversial addition in a type system. However, following \textcite{mlstruct}, our complement types have algebraic foundation, as opposed to a set-theoretic one. The two have different interpretations of subtyping:\footnote{The algebraic interpretation follows by: $\pi \sub \comp \tau \implies \pi \meet \tau \sub \tau \meet \comp \tau \implies \pi \meet \tau \sub \bot$, and $\pi \meet \tau \sub \bot \implies (\pi \meet \tau) \join \comp \tau \sub \comp \tau \implies (\pi \join \comp \tau) \meet (\pi \join \comp \tau) \sub \comp \tau \implies (\pi \join \comp \tau) \meet \top \sub \comp \tau \implies \pi \join \comp \tau \sub \comp \tau \implies \pi \sub \comp \tau$.}
\begin{align*}
    \pi \sub \comp \tau \;&\iff \lnot (\pi \sub \tau) & \text{(set-theoretic)} \\
    \pi \sub \comp \tau \;&\iff \pi \meet \tau \sub \bot & \text{(algebraic)} 
\end{align*}
Set-theoretic-like complement types notoriously make constraint solving harder, introducing negations into the underlying logic of constraint satisfaction. On the other hand, our algebraic complement types provide a weaker condition, but will be of great help to constraint solving -- as we explore in Section \ref{fig:constraints}.

\begin{example}
    Take $\pi = \flext{\mathrm{foo}: \flabsent }{\flftop}$ and $\tau = \flext{\mathrm{foo}: \top}{\flftop}$. Let us consider both interpretations of $\pi \sub \comp \tau$: \begin{description}
        \item[Set-theoretic] It is not the case that $\pi \sub \tau$, thus we have $\pi \sub \comp \tau$. $\checkmark$
        \item[Algebraic] We have $\pi \meet \tau = \flext{\mathrm{foo} : \flfbot }{\flftop} \not\sub \bot$, so we do not have $\pi \sub \comp \tau$. $\lightning$
    \end{description}
    and so we see the two disagree in FL.
    Note that the algebraic interpretation admits fewer subtypes than the set-theoretic one, since for any sets $A$ and $B$: 
    $$A \cap B = \varnothing \implies \lnot(A \subseteq B)$$ 
    % Intuitively, algebraically we require an empty (bottom) intersection between the types, not non-subset.
\end{example}

\paragraph{Summary} To summarise the requirements of \inference{}'s signature: \begin{itemize}
    \item Type constructors must form a distributive lattice.
    \item We use a type language that forms a Boolean algebra.
    \item We must have a subtyping rule in the type system.
\end{itemize} 
To determine these, I was inspired by the requirements of techniques of \textcite{mlsub} and \textcite{mlstruct}.
Later, we see that both Fabric (Chapter \ref{fabric}) and Star (Chapter \ref{star}) successfully implement the signature of \inference{}, showing these requirements are reasonable in practice.

\section{Constraint solving}
\label{sec:constraints}

We now describe the \mlstruct{}-inspired constraint solving process used in \inference{} using the already described setting of the constraint language and signature. 

I largely follow the tradition of the framework by \textcite{pottier-framework} and the Boolean algebraic techniques of \textcite{mlstruct} in \mlstruct{}. The key difference to prior art is the use term rewriting of constraints, leading to a simpler presentation. Furthermore, in Section \ref{sec:morphisms} I give the main contribution of the framework: extension of the type language and constraint solving with homomorphism applications. Giving this extension is made much easier by a constraint-based presentation.

The section is structured as follows: \begin{description}
    \item[\ref{subsec:rewriting} Massaging] We first show that all subtyping constraints $\tau \sub \tau$ can be reduced to a conjunction of \emph{variable-bound} constraints (of syntax $\tau \sub \alpha \,\mid\, \alpha \sub \tau$, as in bounded parametric type schemes).
    \item[\ref{subsec:normalisation} Plumbing] Then, we show how we manipulate and combine these variable-bound constraints into a list-of-bounds normal form. We then perform the \emph{closure} computation.
    \item[\ref{subsec:simplification} Solutions] Lastly, we briefly consider how we can extract a type scheme from a normalised generated constraint, and our approach to simplification.
\end{description} 
Altogether, I reproduce the constraint solving of \textcite{mlstruct} in \mlstruct{} in a constraint-based style that is simpler and easier to extend. 

Constraint solving is given in terms of a small-step term rewriting relation $\step$. The entire solving process is given by its reflexive-transitive closure, $\step^*$.
To show constraint solving always yields correct result, we will rely on a theorem that $\step$ preserves equivalence of constraints (with simple proofs individual steps $\step$):\todo[color=green]{extra}
\begin{theorem}[Semantic preservation]
    If $c \step^* c'$, then $\psi \vdash c$ iff $\psi \vdash c'$.
\end{theorem}
We give the complete rules for $\step$ in Figure \ref{fig:solver}, and will highlight specific rules as needed.

\begin{figure}
    \centering
    \input{Sources/3-Figures/Solver}
    \caption{Definition of constraint solving steps $\step$. Congruence for $\step$ is given by constraint solving contexts $\solvectx$.}
    \label{fig:solver}
\end{figure}

\subsection{Massaging}
\label{subsec:rewriting}
We define the syntax of a \emph{variable bound} $V$ and \emph{variable bounds} $V^*$ as:
\begin{align*}
    \graintro V \tau \sub \alpha \mid \alpha \sub \tau \\
    \graintro {V^*} \tru \mid V \und V^*
\end{align*}
In this section, we show by construction that:
\begin{proposition}[Subtyping constraints yield variable bounds]
    Given $c = (\tau \sub \pi)$, we have that:
    $$ c \step^* \fals \;\text{ or }\; \exists c' = V^* \ldotp c \step^* c' $$
\end{proposition}
To prove this, we introduce 

\subsection{Plumbing}
\label{subsec:normalisation}
\todo[color=red]{}

\subsection{Solutions}
\label{subsec:simplification}
\todo[color=red]{}

\section{Breaking records: Homomorphism extension}
\label{sec:morphisms}

A crucial problem\todo{update problem!!} with typing record extension with a subtyping-based approach, rather than one with row-polymorphism, is that it is difficult to manipulate (e.g.\@ project) a specific field of an existing record solely through subtyping constraints. 
This leads us to the idea that it would be convenient to have \emph{type-level functions} which would perform this sort of manipulation.\todo[color=red]{rewrite}

I propose to follow the algebraic approach and exploit homomorphisms in the type algebra -- well-behaved functions on types -- for typing extensible records. Thanks to homomorphism laws (plus some extra structure we require), we are able to successfully manipulate them in constraint solving, and they thus uncover a new direction in the design of type systems when applying algebraic subtyping.


\begin{example}
    For typing extensible records, we shall later develop a homomorphism $\mathrm{forget}_\ell$, which given a record type sends a given field $\ell$ to $\flftop$.
    By sending the field $\ell$ to $\flftop$ (the top of field types), we can then intersect the result with a singleton of $\ell$ in order to set it to a wanted field type, since $\flftop \meet \phi = \phi$. 
    
    For example:
    \setlength{\tabcolsep}{0pt}
    $$\begin{array}{rll}
        &\hspace{-0.9em}\tau &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \flabsent}{\flabsent} \\
        \mathrm{forget}_\mathrm{foo}( &\hspace{-0.9em}\tau ) &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \flftop}{\flabsent} \\
        \mathrm{forget}_\mathrm{foo}( &\hspace{-0.9em}\tau ) \meet \flext{\mathrm{foo}: \alpha}{\flftop} &\;\hspace{-0.9em}= \flext{\mathrm{foo}: \alpha}{\flabsent}
    \end{array}$$
    This shows how we will replace an absent field in a record with one present with $\alpha$.

    $\mathrm{forget}_\ell$ is reminiscent of the retraction operator on record types of \textcite{operations-on-records}.
\end{example}

\begin{figure}
    \centering
    $$\boxed{\tau \equiv \tau}$$
    \vspace{-2em}
    \begin{align*}
        \morph(\tau \meet \pi) &\equiv \morph(\tau) \meet \morph(\pi) \\
        \morph(\tau \join \pi) &\equiv \morph(\tau) \join \morph(\pi) \\
        \morph(\top) &\equiv \top \\
        \morph(\bot) &\equiv \bot
    \end{align*}
    \vspace{-1em}
    $$ \equivctx ::= \cdots \mid \morph(\equivctx) $$
    \caption{Homomorphism laws in the Boolean algebra of types, which extend the definition of equivalence $\tau \equiv \tau$. Note that $\morph(\comp \tau) \equiv \comp \morph(\tau)$ follows from these laws (by a routine check of complement axioms).}
    \label{fig:morphism-laws}
\end{figure}

\subsection{Signature}

We begin developing the idea formally by extending the syntax of types with \textbf{homomorphism applications} for some homomorphisms $\morph$ specific to a language, and including a homomorphism $\morph = \mathrm{id}$:
$$ \tau ::= \cdots \mid \morph(\tau) $$
requiring that equivalence of types respects the homomorphism laws (Figure \ref{fig:morphism-laws}) and that $\mathrm{id}(\tau) \equiv \tau$. 

In order to solve constraints in the presence of homomorphism applications, we require they have an \emph{adjoint-like}\footnote{Or, perhaps better said, Galois connection-like -- though adjoint is a convenient name.} structure given by left- and right-adjoint homomorphisms $\ladj \morph$ and $\radj \morph$ for all $\morph$. In practice, not all homomorphisms have an adjoint structure (which is why we call this data adjoint-like), thus we also allow \emph{remainder} constraint functions $\ladjrest \morph(\tau) = c$ and $\radjrest \morph(\tau) = c$, so that we have constraint equivalences:
\begin{align*}
\psi \vdash \morph(\tau) \sub \pi &\;\iff \psi \vdash \tau \sub \radj \morph(\pi) \und \radjrest \morph(\pi) \\
\psi \vdash \tau \sub \morph(\pi) &\;\iff \psi \vdash \ladj \morph(\tau) \sub \pi \und \ladjrest \morph(\tau)
\end{align*}
The use of $\ladjrest \morph$ and $\radjrest \morph$ makes it clear why we call these remainders: in the degenerate case that they introduce no further constraint ($\ladjrest \morph = \radjrest \morph = \tru$), $\ladjrest \morph$ and $\radjrest \morph$ are precisely left and right Galois connections to $\morph$.

\begin{example}
    In order to give adjoint-like structure $\mathrm{forget}_\ell$, we effectively need to provide a morphism which can serve as a dual to it. We call this morphism $\mathrm{free}_\ell$, and define it so that it sends a field $\ell$ to $\flfbot$. Then we have the following adjoints and remainders:
    $$\renewcommand\arraystretch{1.5}
    \begin{array}{c|cccc}
    \morph & \ladj \morph & \ladjrest \morph(\tau) & \radj \morph & \radjrest \morph(\tau) \\ \hline 
    \mathrm{forget}_\ell & \mathrm{free}_\ell & \tru & \mathrm{id} & \flext{\ell : \flftop}{\flfbot} \sub \tau \\
    \mathrm{free}_\ell & \mathrm{id} & \tau \sub \flext{\ell : \flfbot}{\flftop} & \mathrm{forget}_\ell & \tru
    \end{array}$$
    Note that $\mathrm{free}_\ell$ and $\mathrm{forget}_\ell$ form an adjoint pair (inspiring their name, cf.\@ free-forgetful adjunction), but other adjoints only occur with remainder constraints.
\end{example}

\subsection{Constraint solving}

We now extend the constraint solving process of Section \ref{sec:constraints} with support for homomorphism applications.\todo[color=red]{}

\subsection{Typing extensible records}
Now that we have describe the use of type homomorphisms in constraint solving, we present the promised concrete application -- typing extensible records, presented for Featherweight Lua. We shall use the homomorphisms $\mathrm{forget}_\ell$ and $\mathrm{free}_\ell$ introduced in the examples. We shall call these \emph{update homomorphisms} and define them as such:
$$ 
\dfrac
  {\tau = \flext{\ell' : \phi_{\ell'},  \overline{\ell : \phi_\ell}}{\phi}}
  {\mathrm{forget}_\ell(\tau) = \flext{\ell' : \flftop,  \overline{\ell : \phi_\ell}}{\phi}}
\qquad 
\dfrac
  {\tau = \flext{\ell' : \phi_{\ell'},  \overline{\ell : \phi_\ell}}{\phi}}
  {\mathrm{free}_\ell(\tau) = \flext{\ell' : \flfbot,  \overline{\ell : \phi_\ell}}{\phi}}
$$
The key property we make use of is that we can give a rule equivalent to the \emph{rule scheme} \textsc{FL-Typ-Ext} -- for which there is no clear way to generate constraints (while avoiding the update problem \cite{operations-on-records}). We instead use:
$$ 
\irule{FL-Typ-HExt}{\Gamma \vdash e : \tau \meet \flext{\ell : \flabsent}{\flftop} \quad \Gamma \vdash e' : \tau'}{\Gamma \vdash \flext{\ell = e'}{e} : \mathrm{forget}_\ell(\tau) \meet \flext{\ell : \tau'}{\flftop}}
$$
\textsc{FL-Typ-HExt} makes it straightforward to generate the necessary constraints -- see Appendix \ref{extra:fl-constraints} for details (sketch of the proofs of homomorphisms laws and equivalence of \textsc{FL-Typ-Ext} and \textsc{FL-Typ-HExt}),\todo[color=green]{extra} thus solving the record update problem under algebraic subtyping without row polymorphism.

\section{Correctness}
\label{sec:correctness}
\todo[color=red]{}

\section{Conclusions}
\label{sec:conclusions}
\todo[color=red]{}

The description of \inference{} in this chapter can be seen as sufficient to instantiate an existing constraint-based type inference framework like $\mathrm{HM}(X)$ of \textcite{constraint-based-hm}. Thus, we do not consider let-polymorphism here -- as is typical of Hindley-Milner systems modelled by $\mathrm{HM}(X)$ -- and focus on the presentation of constraint solving.


